import { GoogleGenerativeAI } from '@google/generative-ai';
import { logger } from '../utils/logger.js';
import { getConfluenceService } from './confluenceService.js';
import patternLearningService from './patternLearningService.js';

export class GeminiService {
  constructor() {
    // Support both direct API key and Google Application Credentials
    this.apiKey = process.env.GOOGLE_API_KEY || process.env.GEMINI_API_KEY;
    this.currentModel = process.env.GEMINI_MODEL || 'gemini-2.5-pro';
    
    if (!this.apiKey && !process.env.GOOGLE_APPLICATION_CREDENTIALS) {
      logger.warn('Gemini/Google AI not configured. Set either GOOGLE_API_KEY or GOOGLE_APPLICATION_CREDENTIALS');
      return;
    }

    if (this.apiKey) {
      // Use direct API key for Gemini
      this.genAI = new GoogleGenerativeAI(this.apiKey);
      this.initializeModel(this.currentModel);
    } else {
      // For Vertex AI, you would need different initialization
      logger.info(`Google AI configured with service account: ${process.env.GOOGLE_APPLICATION_CREDENTIALS}`);
      // Note: For Vertex AI, you'd need to use @google-cloud/aiplatform instead
    }
  }

  initializeModel(modelName) {
    if (!this.genAI) return;
    
    this.model = this.genAI.getGenerativeModel({ model: modelName });
    this.currentModel = modelName;
    logger.info(`Gemini API configured with model: ${modelName}`);
  }

  getCurrentModel() {
    return this.currentModel;
  }

  async setModel(modelName) {
    const validModels = ['gemini-2.5-flash', 'gemini-2.5-pro'];
    if (!validModels.includes(modelName)) {
      throw new Error(`Invalid model name. Must be one of: ${validModels.join(', ')}`);
    }

    this.initializeModel(modelName);
    logger.info(`Model switched to: ${modelName}`);
    return modelName;
  }

  async generateTestCases(ticket, options = {}) {
    logger.info(`=== ENTERING generateTestCases ===`);
    logger.info(`Ticket: ${ticket.key}`);
    logger.info(`Options received:`, JSON.stringify(options));
    logger.info(`Options keys:`, Object.keys(options));
    logger.info(`testCount from options: ${options.testCount}`);
    logger.info(`includePerformance: ${options.includePerformance}`);
    
    // Fetch Confluence documentation if available
    const confluenceService = getConfluenceService();
    const documentation = await confluenceService.fetchTicketDocumentation(ticket);
    
    if (documentation && documentation.scenarios.length > 0) {
      logger.info(`Found ${documentation.scenarios.length} scenarios from Confluence`);
      // Enhance ticket with Confluence data
      ticket.confluenceScenarios = documentation.scenarios;
      ticket.technicalSpecs = documentation.technicalSpecs;
    }
    
    // Generate patterns and suggestions from pattern learning service
    const patterns = await patternLearningService.generateWithPatterns(ticket, options);
    if (patterns) {
      logger.info('Using learned patterns for test generation');
      options.patterns = patterns;
      options.selectors = patterns.selectors;
      options.customCommands = patterns.customCommands;
    }
    
    // If repository path is provided, learn from element properties files
    if (options.repositoryPath) {
      const elementPatterns = await this.learnFromElementProperties(options.repositoryPath);
      if (elementPatterns) {
        logger.info('Learned element patterns from properties files');
        options.elementPatterns = elementPatterns;
      }
    }
    
    if (!this.model) {
      logger.warn('Gemini API not configured, returning fallback test cases');
      logger.warn('API Key status:', this.apiKey ? 'Present' : 'Missing');
      logger.warn('Model status:', this.currentModel);
      const mockResult = this.generateMockTestCases(ticket, options);
      return mockResult.testCases || [];
    }

    const prompt = this.buildTestCasePrompt(ticket, options);
    logger.info('Generating tests with Gemini API for ticket:', ticket.key);
    
    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      logger.info('Gemini API response received, parsing test cases');
      const parsed = this.parseTestCases(text);
      // Extract testCases array from the parsed result
      return parsed.testCases || [];
    } catch (error) {
      logger.error('Gemini API error:', error);
      logger.warn('Falling back to fallback test cases due to API error');
      const mockResult = this.generateMockTestCases(ticket, options);
      // The mock result includes the full test count and non-functional tests
      logger.info(`Mock generation completed with ${mockResult.testCases?.length || 0} total tests`);
      return mockResult.testCases || [];
    }
  }

  generateMockTestCases(ticket, options = {}) {
    logger.info(`=== ENTERING generateMockTestCases ===`);
    logger.info(`Ticket: ${ticket.key}, Type: ${ticket.type}`);
    logger.info(`Options:`, JSON.stringify(options));
    
    const { 
      style = 'BDD',
      testTypes = ['functional'],
      includePerformance = false,
      includeSecurity = false,
      includeAccessibility = false,
      testCount = 5
    } = options;
    
    logger.info(`After destructuring - testTypes=${JSON.stringify(testTypes)}, includePerformance=${includePerformance}, includeSecurity=${includeSecurity}, includeAccessibility=${includeAccessibility}, testCount=${testCount}, ticketType=${ticket.type}`);
    
    // If we have Confluence scenarios, use them to generate specific test cases
    if (ticket.confluenceScenarios && ticket.confluenceScenarios.length > 0) {
      return this.generateTestsFromConfluenceScenarios(ticket, options);
    }
    
    // Check if this is an Eden ticket
    const isEdenTicket = this.isEdenTicket(ticket);
    
    if (isEdenTicket) {
      return this.generateEdenTestCases(ticket, options);
    }
    
    // Generate more specific mock test cases based on ticket type
    let mockTestCases = [];
    
    if (ticket.type?.toLowerCase() === 'bug') {
      // Parse steps to reproduce if provided
      const steps = this.parseStepsToReproduce(ticket.stepsToReproduce || ticket.description);
      const actualBehavior = ticket.actualBehavior || 'System does not behave as expected';
      const expectedBehavior = ticket.expectedBehavior || 'System should work correctly';
      
      mockTestCases = [
        {
          testType: 'functional',
          title: `Verify Bug Fix: ${ticket.summary}`,
          objective: `Verify that the bug has been fixed and the system now works as expected`,
          preconditions: `Bug fix deployed to test environment. ${this.extractPreconditions(ticket)}`,
          priority: 'High',
          steps: steps.length > 0 ? 
            steps.map((step, idx) => ({
              action: step,
              expectedResult: idx === steps.length - 1 ? 
                expectedBehavior : 
                this.getStepExpectedResult(step)
            })) : 
            [
              { action: 'Navigate to the affected feature', expectedResult: 'Feature loads correctly' },
              { action: 'Perform the action that previously caused the bug', expectedResult: expectedBehavior },
              { action: 'Verify the correct behavior', expectedResult: 'System functions as intended' }
            ],
          expectedResult: `✅ PASS: ${expectedBehavior} | ❌ FAIL: Bug still exists if ${actualBehavior}`
        },
        {
          testType: 'functional',
          title: `Edge Case Testing: ${ticket.summary}`,
          objective: `Test the fix with various data sets and scenarios to ensure complete resolution`,
          preconditions: `Bug fix deployed. ${this.extractPreconditions(ticket)}`,
          priority: 'High',
          steps: this.generateBugEdgeCaseSteps(ticket, expectedBehavior),
          expectedResult: `All variations work correctly: ${expectedBehavior}`
        },
        {
          testType: 'functional',
          title: `Regression Test: ${ticket.summary}`,
          objective: `Ensure the fix doesn't break existing functionality`,
          preconditions: this.extractPreconditions(ticket),
          priority: 'Medium',
          steps: this.generateRegressionSteps(ticket, expectedBehavior),
          expectedResult: 'No regression issues - all related features continue to work'
        },
        {
          title: `Performance Impact: ${ticket.summary}`,
          objective: `Verify the bug fix doesn't negatively impact performance`,
          preconditions: `Performance monitoring tools available. ${this.extractPreconditions(ticket)}`,
          priority: 'Medium',
          steps: [
            { action: 'Establish baseline performance metrics', expectedResult: 'Baseline recorded' },
            { action: 'Execute the fixed functionality under normal load', expectedResult: 'Response time within acceptable limits' },
            { action: 'Compare metrics with baseline', expectedResult: 'No significant performance degradation' }
          ],
          expectedResult: 'Performance remains within acceptable thresholds after bug fix'
        },
        {
          testType: 'functional',
          title: `Cross-Platform Verification: ${ticket.summary}`,
          objective: `Ensure the bug fix works across all supported platforms`,
          preconditions: `Access to all supported platforms. ${this.extractPreconditions(ticket)}`,
          priority: 'High',
          steps: [
            { action: 'Test fix on primary platform', expectedResult: 'Bug is fixed on primary platform' },
            { action: 'Test fix on secondary platforms', expectedResult: 'Bug is fixed on all platforms' },
            { action: 'Verify consistent behavior across platforms', expectedResult: 'Behavior is consistent' }
          ],
          expectedResult: 'Bug fix is effective and consistent across all platforms'
        }
      ];
    } else {
      // Story/Task/Enhancement
      const acceptanceCriteria = this.parseAcceptanceCriteria(ticket.acceptanceCriteria || ticket.description);
      const qaScenarios = this.extractQAValidationScenarios(ticket);
      
      // If QA scenarios are found, generate tests from them first
      if (qaScenarios.length > 0) {
        mockTestCases = this.generateTestsFromQAScenarios(ticket, qaScenarios, acceptanceCriteria);
        logger.info(`Generated ${mockTestCases.length} tests from QA scenarios`);
        // Don't skip the rest of the generation - continue to add more tests
      }
      
      // If we don't have any tests yet or need more standard tests
      if (mockTestCases.length === 0) {
        const featureSteps = this.generateFeatureSteps(ticket, acceptanceCriteria);
        mockTestCases = [
        {
          testType: 'functional',
          title: `Happy Path: ${ticket.summary}`,
          objective: `Validate that all acceptance criteria are met for ${ticket.summary}`,
          preconditions: this.extractPreconditions(ticket),
          priority: 'High',
          steps: featureSteps.happyPath,
          expectedResult: acceptanceCriteria.length > 0 ? 
            `All acceptance criteria are satisfied: ${acceptanceCriteria.join(', ')}` :
            'Feature completes successfully with valid data',
          testData: this.generateTestData(ticket)
        },
        {
          testType: 'functional',
          title: `Input Validation: ${ticket.summary}`,
          objective: `Test validation rules and error handling for ${ticket.summary}`,
          preconditions: this.extractPreconditions(ticket),
          priority: 'High',
          steps: featureSteps.validation,
          expectedResult: 'All validation rules work correctly and appropriate error messages are shown',
          testData: this.generateInvalidTestData(ticket)
        },
        {
          testType: 'functional',
          title: `Edge Cases: ${ticket.summary}`,
          objective: `Test boundary conditions and special scenarios for ${ticket.summary}`,
          preconditions: this.extractPreconditions(ticket),
          priority: 'Medium',
          steps: featureSteps.edgeCases,
          expectedResult: 'All edge cases are handled gracefully without system errors',
          testData: this.generateEdgeCaseData(ticket)
        },
        {
          testType: 'functional',
          title: `Integration Test: ${ticket.summary}`,
          objective: `Verify integration with other system components`,
          preconditions: `All integrated systems available. ${this.extractPreconditions(ticket)}`,
          priority: 'High',
          steps: [
            { action: 'Test data flow to downstream systems', expectedResult: 'Data transmitted correctly' },
            { action: 'Verify upstream dependencies', expectedResult: 'Dependencies functioning properly' },
            { action: 'Check API interactions', expectedResult: 'APIs respond as expected' },
            { action: 'Validate data consistency', expectedResult: 'Data remains consistent across systems' }
          ],
          expectedResult: 'Feature integrates seamlessly with other components',
          testData: this.generateTestData(ticket)
        },
        {
          title: `User Acceptance: ${ticket.summary}`,
          objective: `Verify feature meets user acceptance criteria and business requirements`,
          preconditions: `UAT environment configured. ${this.extractPreconditions(ticket)}`,
          priority: 'High',
          steps: [
            { action: 'Complete user workflow end-to-end', expectedResult: 'Workflow completes successfully' },
            { action: 'Verify business rules implementation', expectedResult: 'Business logic correctly applied' },
            { action: 'Check UI/UX requirements', expectedResult: 'Interface meets specifications' },
            { action: 'Validate user feedback incorporation', expectedResult: 'User requirements satisfied' }
          ],
          expectedResult: 'Feature meets all acceptance criteria and user expectations',
          testData: this.generateTestData(ticket)
        }
      ];
      }
    }

    // Calculate how many tests to generate for each type
    const typesToGenerate = [];
    if (testTypes.includes('functional') || (!includePerformance && !includeSecurity && !includeAccessibility)) {
      typesToGenerate.push('functional');
    }
    if (includePerformance || testTypes.includes('performance')) typesToGenerate.push('performance');
    if (includeSecurity || testTypes.includes('security')) typesToGenerate.push('security');
    if (includeAccessibility || testTypes.includes('accessibility')) typesToGenerate.push('accessibility');
    
    // For functional tests, use the full testCount
    // Non-functional tests are added IN ADDITION to functional tests
    const functionalCount = typesToGenerate.includes('functional') ? testCount : 0;
    
    // Generate the appropriate number of functional tests based on testCount
    if (functionalCount > 0) {
      logger.info(`Before adding more tests: mockTestCases.length=${mockTestCases.length}, functionalCount=${functionalCount}`);
      
      // If we don't have enough mock test cases, generate more based on the ticket
      while (mockTestCases.length < functionalCount) {
        const testIndex = mockTestCases.length + 1;
        const additionalTest = this.generateAdditionalTestCase(ticket, testIndex);
        mockTestCases.push(additionalTest);
        logger.info(`Added test ${testIndex}, now have ${mockTestCases.length} tests`);
      }
      
      // Limit to exactly the requested count
      if (mockTestCases.length > functionalCount) {
        mockTestCases = mockTestCases.slice(0, functionalCount);
      }
      
      logger.info(`After adding functional tests: mockTestCases.length=${mockTestCases.length}`);
    }
    
    // Add non-functional tests if requested
    if (includePerformance || testTypes.includes('performance')) {
      // Add multiple performance tests based on coverage
      const perfTests = [
        {
          title: `Performance Test - Response Time: ${ticket.summary}`,
          objective: 'Validate system response times under normal load',
          preconditions: 'System under normal load conditions',
          priority: 'High',
          testType: 'performance',
          metrics: {
            responseTime: '<500ms',
            throughput: '>100 req/s',
            resourceUsage: '<70% CPU'
          },
          steps: [
            { action: 'Set up performance monitoring', expectedResult: 'Monitoring tools configured' },
            { action: 'Execute performance scenario', expectedResult: 'Load generated successfully' },
            { action: 'Measure response times', expectedResult: 'Response times within acceptable limits' },
            { action: 'Check resource utilization', expectedResult: 'CPU/Memory usage within thresholds' }
          ],
          expectedResult: 'System meets performance requirements'
        }
      ];
      
      if (testCount > 6) {
        perfTests.push({
          title: `Performance Test - Load Testing: ${ticket.summary}`,
          objective: 'Validate system behavior under heavy load',
          preconditions: 'Load testing environment configured',
          priority: 'High',
          testType: 'performance',
          metrics: {
            responseTime: '<2000ms under load',
            throughput: '>500 req/s',
            errorRate: '<1%'
          },
          steps: [
            { action: 'Configure load testing with 100 concurrent users', expectedResult: 'Load test configured' },
            { action: 'Ramp up to peak load over 5 minutes', expectedResult: 'Load increased gradually' },
            { action: 'Maintain peak load for 15 minutes', expectedResult: 'System remains stable' },
            { action: 'Monitor error rates and response times', expectedResult: 'Metrics within acceptable range' }
          ],
          expectedResult: 'System handles peak load without degradation'
        });
      }
      
      mockTestCases.push(...perfTests);
    }
    
    if (includeSecurity || testTypes.includes('security')) {
      mockTestCases.push({
        title: `Security Test: ${ticket.summary}`,
        objective: 'Validate security controls and check for vulnerabilities',
        preconditions: 'Test user accounts with various permission levels',
        priority: 'Critical',
        testType: 'security',
        securityChecks: {
          authentication: true,
          authorization: true,
          dataProtection: true,
          inputValidation: true
        },
        steps: [
          { action: 'Test authentication mechanisms', expectedResult: 'Authentication properly enforced' },
          { action: 'Verify authorization controls', expectedResult: 'Access control working correctly' },
          { action: 'Check for common vulnerabilities', expectedResult: 'No vulnerabilities detected' },
          { action: 'Validate data encryption', expectedResult: 'Sensitive data properly encrypted' }
        ],
        expectedResult: 'System passes security validation'
      });
    }
    
    if (includeAccessibility || testTypes.includes('accessibility')) {
      mockTestCases.push({
        title: `Accessibility Test: ${ticket.summary}`,
        objective: 'Ensure compliance with WCAG 2.1 Level AA standards',
        preconditions: 'Screen reader and accessibility tools available',
        priority: 'High',
        testType: 'accessibility',
        wcagLevel: 'AA',
        accessibilityChecks: {
          screenReader: true,
          keyboardNavigation: true,
          colorContrast: true,
          altText: true
        },
        steps: [
          { action: 'Test with screen reader', expectedResult: 'All content readable and navigable' },
          { action: 'Verify keyboard navigation', expectedResult: 'All interactive elements accessible via keyboard' },
          { action: 'Check color contrast ratios', expectedResult: 'Meets WCAG contrast requirements' },
          { action: 'Validate ARIA labels', expectedResult: 'Proper ARIA attributes present' }
        ],
        expectedResult: 'Meets accessibility standards'
      });
    }

    logger.info(`Final test count before return: mockTestCases.length=${mockTestCases.length}`);
    return { testCases: mockTestCases, style };
  }

  async learnFromElementProperties(repoPath) {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const elementPatterns = {
        locators: {},
        pageObjects: {},
        frameworks: new Set(),
        smartLocatorStrategies: []
      };
      
      // Look for properties files in common locations
      const propertiesLocations = [
        '/src/main/resources/elements',
        '/src/test/resources/elements',
        '/src/main/resources/locators',
        '/src/test/resources/locators'
      ];
      
      for (const location of propertiesLocations) {
        const fullPath = path.join(repoPath, location);
        try {
          const files = await this.findPropertiesFiles(fullPath);
          for (const file of files) {
            const content = await fs.readFile(file, 'utf8');
            this.parsePropertiesFile(content, elementPatterns, file);
          }
        } catch (e) {
          // Directory doesn't exist, continue
        }
      }
      
      // Also look for Page Object files
      await this.findPageObjectPatterns(repoPath, elementPatterns);
      
      // Convert frameworks Set to Array for serialization
      elementPatterns.frameworks = Array.from(elementPatterns.frameworks);
      
      // Generate smart locator strategies based on learned patterns
      elementPatterns.smartLocatorStrategies = this.generateSmartLocatorStrategies(elementPatterns);
      
      return elementPatterns;
    } catch (error) {
      logger.error('Error learning from element properties:', error);
      return null;
    }
  }
  
  async findPropertiesFiles(dirPath) {
    const fs = await import('fs/promises');
    const path = await import('path');
    const files = [];
    
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        if (entry.isDirectory() && !entry.name.startsWith('.')) {
          files.push(...await this.findPropertiesFiles(fullPath));
        } else if (entry.name.endsWith('.properties')) {
          files.push(fullPath);
        }
      }
    } catch (e) {
      // Directory doesn't exist
    }
    
    return files;
  }
  
  parsePropertiesFile(content, patterns, filePath) {
    const lines = content.split('\n');
    const fileName = filePath.split('/').pop().replace('.properties', '');
    
    if (!patterns.pageObjects[fileName]) {
      patterns.pageObjects[fileName] = {};
    }
    
    for (const line of lines) {
      if (line.trim() && !line.startsWith('#')) {
        const [key, value] = line.split('=').map(s => s.trim());
        if (key && value) {
          patterns.locators[key] = value;
          patterns.pageObjects[fileName][key] = value;
          
          // Detect framework from locator patterns
          if (value.includes('xpath:') || value.includes('css:')) {
            patterns.frameworks.add('selenium');
          }
          if (value.includes('@FindBy')) {
            patterns.frameworks.add('page-factory');
          }
          if (value.includes('data-testid') || value.includes('data-qa')) {
            patterns.frameworks.add('modern-testing');
          }
        }
      }
    }
  }
  
  async findPageObjectPatterns(repoPath, patterns) {
    const fs = await import('fs/promises');
    const path = await import('path');
    
    const pageObjectDirs = [
      '/src/main/java',
      '/src/test/java'
    ];
    
    for (const dir of pageObjectDirs) {
      const fullPath = path.join(repoPath, dir);
      try {
        await this.scanForPageObjects(fullPath, patterns);
      } catch (e) {
        // Directory doesn't exist
      }
    }
  }
  
  async scanForPageObjects(dirPath, patterns) {
    const fs = await import('fs/promises');
    const path = await import('path');
    
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        if (entry.isDirectory() && !entry.name.startsWith('.') && 
            entry.name !== 'target' && entry.name !== 'build') {
          await this.scanForPageObjects(fullPath, patterns);
        } else if (entry.name.endsWith('.java') && 
                  (entry.name.includes('Page') || entry.name.includes('Screen'))) {
          const content = await fs.readFile(fullPath, 'utf8');
          this.extractPageObjectPatterns(content, patterns, entry.name);
        }
      }
    } catch (e) {
      // Error reading directory
    }
  }
  
  extractPageObjectPatterns(javaContent, patterns, fileName) {
    // Extract @FindBy annotations
    const findByPattern = /@FindBy\s*\(([^)]+)\)/g;
    let match;
    while ((match = findByPattern.exec(javaContent)) !== null) {
      const annotation = match[1];
      patterns.frameworks.add('page-factory');
      
      // Parse the annotation content for locator strategies
      if (annotation.includes('id =')) {
        const idMatch = annotation.match(/id\s*=\s*"([^"]+)"/); 
        if (idMatch) {
          patterns.locators[`${fileName}_id_${idMatch[1]}`] = `id:${idMatch[1]}`;
        }
      }
      if (annotation.includes('xpath =')) {
        const xpathMatch = annotation.match(/xpath\s*=\s*"([^"]+)"/); 
        if (xpathMatch) {
          patterns.locators[`${fileName}_xpath`] = `xpath:${xpathMatch[1]}`;
        }
      }
    }
    
    // Extract method patterns that suggest framework usage
    if (javaContent.includes('WebElement') || javaContent.includes('WebDriver')) {
      patterns.frameworks.add('selenium');
    }
    if (javaContent.includes('BaseTest') || javaContent.includes('BasePage')) {
      patterns.frameworks.add('custom-framework');
    }
    if (javaContent.includes('containerScreen()') || javaContent.includes('homeScreen()')) {
      patterns.frameworks.add('screen-object-model');
    }
  }
  
  generateSmartLocatorStrategies(patterns) {
    const strategies = [];
    
    // Analyze learned locators to determine best strategies
    const locatorTypes = new Set();
    for (const [key, value] of Object.entries(patterns.locators)) {
      if (value.includes('data-testid')) locatorTypes.add('data-testid');
      if (value.includes('data-qa')) locatorTypes.add('data-qa');
      if (value.includes('id:')) locatorTypes.add('id');
      if (value.includes('xpath:')) locatorTypes.add('xpath');
      if (value.includes('css:')) locatorTypes.add('css');
    }
    
    // Build priority order based on what's used in the codebase
    if (locatorTypes.has('data-testid')) {
      strategies.push({
        type: 'data-testid',
        priority: 1,
        example: "By.cssSelector(\"[data-testid='elementName']\")"
      });
    }
    if (locatorTypes.has('data-qa')) {
      strategies.push({
        type: 'data-qa',
        priority: 2,
        example: "By.cssSelector(\"[data-qa='elementName']\")"
      });
    }
    if (locatorTypes.has('id')) {
      strategies.push({
        type: 'id',
        priority: 3,
        example: "By.id(\"elementName\")"
      });
    }
    
    // Always include these fallback strategies
    strategies.push({
      type: 'aria-label',
      priority: 4,
      example: "By.cssSelector(\"[aria-label*='elementName']\")"
    });
    strategies.push({
      type: 'text-content',
      priority: 5,
      example: "By.xpath(\"//button[contains(text(), 'elementName')]\")"
    });
    strategies.push({
      type: 'class-text-combo',
      priority: 6,
      example: "By.xpath(\"//*[contains(@class, 'button') and contains(text(), 'elementName')]\")"
    });
    
    return strategies;
  }
  
  buildTestCasePrompt(ticket, options) {
    // Use direct property access instead of destructuring due to object issues
    const style = options.style || 'BDD';
    const types = options.types || ['positive', 'negative', 'edge'];
    const testTypes = options.testTypes || ['functional'];
    const includePerformance = options.includePerformance || false;
    const includeSecurity = options.includeSecurity || false;
    const includeAccessibility = options.includeAccessibility || false;
    
    // Customize prompt based on ticket type
    let contextualGuidance = '';
    if (ticket.type?.toLowerCase() === 'bug') {
      contextualGuidance = `
This is a BUG ticket. Focus on:
- Reproducing the bug described
- Verifying the fix works correctly
- Testing regression scenarios
- Ensuring the bug doesn't reoccur in edge cases
- Testing related functionality that might be affected`;
    } else if (ticket.type?.toLowerCase() === 'story' || ticket.type?.toLowerCase() === 'task') {
      contextualGuidance = `
This is a ${ticket.type.toUpperCase()} ticket. Focus on:
- Validating all acceptance criteria
- Testing happy path scenarios thoroughly
- Testing error handling and validation
- Checking boundary conditions
- Verifying user experience flows
- Testing integration with existing features
${this.extractQAValidationScenarios(ticket).length > 0 ? 
`\n- CRITICAL: The following QA validation scenarios MUST be tested:
${this.extractQAValidationScenarios(ticket).map((s, i) => `  ${i+1}. ${s}`).join('\n')}` : ''}`;
    } else if (ticket.type?.toLowerCase() === 'improvement' || ticket.type?.toLowerCase() === 'enhancement') {
      contextualGuidance = `
This is an IMPROVEMENT ticket. Focus on:
- Comparing before/after behavior
- Performance improvements if applicable
- Backward compatibility
- User experience enhancements
- Edge cases with the improved feature`;
    }
    
    // Add element patterns to the prompt if available
    let elementPatternsSection = '';
    if (options.elementPatterns) {
      elementPatternsSection = `

PROJECT-SPECIFIC PATTERNS:
=========================
${options.elementPatterns.frameworks?.length > 0 ? `Detected Frameworks: ${options.elementPatterns.frameworks.join(', ')}` : ''}
${options.elementPatterns.smartLocatorStrategies?.length > 0 ? `
Locator Strategy Priority (use these in order of preference):
${options.elementPatterns.smartLocatorStrategies.map(s => `  ${s.priority}. ${s.type}: ${s.example}`).join('\n')}` : ''}
${Object.keys(options.elementPatterns.pageObjects || {}).length > 0 ? `
Available Page Objects: ${Object.keys(options.elementPatterns.pageObjects).join(', ')}` : ''}

IMPORTANT: When generating automation code:
- Use the project's existing framework patterns (${options.elementPatterns.frameworks?.join(', ') || 'selenium'})
- Implement multi-strategy element location with fallback mechanisms
- For each UI element, provide multiple locator strategies in priority order
- Use data-testid attributes when available, fall back to id, xpath, aria-label, etc.
- Generate helper methods for element location that try multiple strategies`;
    }
    
    return `You are an expert QA engineer creating comprehensive test cases for a web application. Generate specific, actionable test cases for this JIRA ticket:

TICKET INFORMATION:
==================
Title: ${ticket.summary}
Type: ${ticket.type || 'Story'}
Description: ${ticket.description || 'No description provided'}
${ticket.type === 'Bug' ? `
Steps to Reproduce: ${ticket.stepsToReproduce || 'Not provided'}
Actual Behavior: ${ticket.actualBehavior || 'System behaves incorrectly'}
Expected Behavior: ${ticket.expectedBehavior || 'System should work correctly'}` : ''}
${ticket.acceptanceCriteria ? `Acceptance Criteria: ${ticket.acceptanceCriteria}` : ''}
${this.extractQAValidationScenarios(ticket).length > 0 ? `
QA VALIDATION REQUIREMENTS:
${this.extractQAValidationScenarios(ticket).map((s, i) => `${i+1}. ${s}`).join('\n')}` : ''}
${ticket.confluenceScenarios && ticket.confluenceScenarios.length > 0 ? `
CONFLUENCE DOCUMENTATION SCENARIOS:
${ticket.confluenceScenarios.map((s, i) => `${i+1}. ${s}`).join('\n')}` : ''}
${ticket.technicalSpecs ? `
TECHNICAL SPECIFICATIONS:
${ticket.technicalSpecs.endpoints?.length > 0 ? `Endpoints: ${JSON.stringify(ticket.technicalSpecs.endpoints)}` : ''}
${ticket.technicalSpecs.uiElements?.length > 0 ? `UI Elements: ${ticket.technicalSpecs.uiElements.join(', ')}` : ''}
${ticket.technicalSpecs.events?.length > 0 ? `Events: ${ticket.technicalSpecs.events.join(', ')}` : ''}` : ''}
${contextualGuidance}
${elementPatternsSection}

REQUIREMENTS:
=============
Generate test cases covering the following types:

IMPORTANT: Non-functional tests should be ADDITIONAL to functional tests, not replace them.
${testTypes.includes('functional') || (!includePerformance && !includeSecurity && !includeAccessibility) ? `
1. FUNCTIONAL TESTS (Generate ${options.testCount || 5} test cases):
${types.includes('positive') ? '   - Positive/Happy path scenarios' : ''}
${types.includes('negative') ? '   - Negative scenarios and error handling' : ''}
${types.includes('edge') ? '   - Edge cases and boundary conditions' : ''}` : ''}
${includePerformance || testTypes.includes('performance') ? `

2. PERFORMANCE TESTS (Generate 2 ADDITIONAL test cases):
   - Response time validation (page load < 3s, API calls < 500ms)
   - Throughput testing (concurrent users, requests per second)
   - Resource usage monitoring (CPU, memory, network)
   - Load testing scenarios
   - Include specific performance metrics and thresholds` : ''}
${includeSecurity || testTypes.includes('security') ? `

3. SECURITY TESTS (Generate 2 ADDITIONAL test cases):
   - Authentication validation (login, logout, session management)
   - Authorization checks (role-based access, permissions)
   - Input validation (SQL injection, XSS, CSRF protection)
   - Data protection (encryption, secure transmission)
   - Security headers and CORS policies` : ''}
${includeAccessibility || testTypes.includes('accessibility') ? `

4. ACCESSIBILITY TESTS (Generate 2 ADDITIONAL test cases):
   - Screen reader compatibility (NVDA, JAWS, VoiceOver)
   - Keyboard navigation (tab order, focus management)
   - WCAG 2.1 Level AA compliance
   - Color contrast ratios (4.5:1 for normal text, 3:1 for large text)
   - ARIA labels and roles
   - Alternative text for images` : ''}

Each test case MUST include:
1. title: Clear, specific test case title
2. objective: What this test validates (1-2 sentences)
3. preconditions: Specific setup requirements
4. priority: "High", "Medium", or "Low" (Critical for security tests)
5. testType: "functional", "performance", "security", or "accessibility"
6. steps: Array of step objects, each with:
   - action: Specific user action (e.g., "Click the 'Submit' button", "Enter 'test@example.com' in email field")
   - expectedResult: Specific expected result (e.g., "Error message 'Invalid email' appears", "Page redirects to dashboard")
7. expectedResult: Overall expected outcome
8. testData: Specific test data if needed (optional)

For non-functional tests, also include:
- Performance tests: metrics object with responseTime, throughput, resourceUsage fields
- Security tests: securityChecks object with boolean flags for each check performed
- Accessibility tests: accessibilityChecks object and wcagLevel field

CRITICAL INSTRUCTIONS FOR SPECIFICITY:
- NEVER use generic placeholders like "the feature" or "the system"
- ALWAYS use the specific feature names and UI elements from the ticket
- Include EXACT error messages, button labels, and field names
- Provide REAL test data values (emails, passwords, dates, etc.)
- Each step must be so specific that a new tester could execute it without confusion
- Expected results must be measurable and observable
- For bugs: Focus on verifying the fix works, not reproducing the original issue
- Include specific browser/device requirements if mentioned

IMPORTANT - VALIDATION POINTS:
- EVERY test step MUST have BOTH an action AND an expectedResult
- The "expectedResult" field is MANDATORY and cannot be empty
- Expected results should describe what the user should see/observe after the action
- Examples of good expectedResult values:
  * "Focus moves to the 'Play' button"
  * "The 'Restart' button becomes highlighted with a blue border"
  * "Error message 'Invalid input' appears below the field"
  * "Page scrolls to the reviews section"
  * "Loading spinner displays for 2-3 seconds then disappears"

TOTAL TEST COUNT EXPECTATION:
${options.testCount ? `- Functional tests: ${options.testCount}` : '- Functional tests: 4-6'}
${includePerformance ? '- Performance tests: 2 (ADDITIONAL)' : ''}
${includeSecurity ? '- Security tests: 2 (ADDITIONAL)' : ''}
${includeAccessibility ? '- Accessibility tests: 2 (ADDITIONAL)' : ''}
${includePerformance || includeSecurity || includeAccessibility ? 
`- TOTAL: ${options.testCount || 5} functional + ${
  (includePerformance ? 2 : 0) + 
  (includeSecurity ? 2 : 0) + 
  (includeAccessibility ? 2 : 0)
} non-functional = ${
  (options.testCount || 5) + 
  (includePerformance ? 2 : 0) + 
  (includeSecurity ? 2 : 0) + 
  (includeAccessibility ? 2 : 0)
} tests` : ''}

Format your response as a JSON array of test case objects. Example format:
[
  {
    "title": "Verify user can successfully login with valid credentials",
    "objective": "Validate that users can access the system with correct username and password",
    "preconditions": "User account 'testuser@example.com' exists with password 'Test123!'",
    "priority": "High",
    "testType": "functional",
    "steps": [
      {"action": "Navigate to login page at /login", "expectedResult": "Login form is displayed with email and password fields"},
      {"action": "Enter 'testuser@example.com' in the email field", "expectedResult": "Email is accepted and displayed in the field"},
      {"action": "Enter 'Test123!' in the password field", "expectedResult": "Password is masked with dots"},
      {"action": "Click the 'Sign In' button", "expectedResult": "Loading spinner appears briefly"}
    ],
    "expectedResult": "User is redirected to dashboard at /dashboard and sees welcome message",
    "testData": {"email": "testuser@example.com", "password": "Test123!"}
  }
]`;
  }

  parseTestCases(text) {
    try {
      // First try to find JSON array in the text
      const jsonMatch = text.match(/```json\s*([\s\S]*?)```/);
      if (jsonMatch) {
        const jsonContent = jsonMatch[1];
        const parsed = JSON.parse(jsonContent);
        
        // Convert the format to match what frontend expects
        if (Array.isArray(parsed)) {
          return {
            testCases: parsed.map(tc => ({
              title: tc.Title || tc.title,
              objective: tc.Description || tc.description || tc.objective,
              preconditions: Array.isArray(tc.Preconditions) 
                ? tc.Preconditions.join('; ') 
                : tc.Preconditions || tc.preconditions || '',
              steps: this.convertStepsFormat(tc.Steps || tc.steps),
              expectedResult: tc['Expected Result'] || tc.expectedResult || tc.expected_result || '',
              priority: tc.Priority || tc.priority || 'Medium',
              testType: tc.testType || tc.test_type || 'functional',
              testData: tc['Test Data'] || tc.testData || tc.test_data,
              // Non-functional test specific fields
              metrics: tc.metrics,
              securityChecks: tc.securityChecks || tc.security_checks,
              accessibilityChecks: tc.accessibilityChecks || tc.accessibility_checks,
              wcagLevel: tc.wcagLevel || tc.wcag_level
            }))
          };
        }
      }
      
      // Try direct JSON parse
      const parsed = JSON.parse(text);
      if (parsed.testCases) {
        return parsed;
      }
      if (Array.isArray(parsed)) {
        return { testCases: parsed };
      }
      
      return { testCases: [parsed] };
    } catch (error) {
      logger.error('Failed to parse Gemini response, using fallback:', error.message);
      // Fallback to simple format
      return {
        testCases: [{
          title: 'Generated Test Case',
          objective: 'AI-generated test case',
          preconditions: 'System is accessible',
          steps: [
            { action: 'Perform test action', expectedResult: 'Expected outcome' }
          ],
          expectedResult: 'Test passes successfully',
          priority: 'Medium'
        }]
      };
    }
  }

  convertStepsFormat(steps) {
    if (!steps) return [];
    
    // If steps is already in the right format, ensure expectedResult is not empty
    if (Array.isArray(steps) && steps.length > 0 && typeof steps[0] === 'object' && 'action' in steps[0]) {
      return steps.map(step => ({
        action: step.action,
        expectedResult: step.expected || step.expectedResult || this.generateDefaultExpected(step.action)
      }));
    }
    
    // If steps is an array of strings (BDD format)
    if (Array.isArray(steps)) {
      return steps.map((step, index) => {
        // Try to parse Given/When/Then format
        const match = step.match(/^(Given|When|Then|And)\s+(.+)/i);
        if (match) {
          const [, keyword, content] = match;
          if (keyword.toLowerCase() === 'then' || keyword.toLowerCase() === 'and' && index > 0 && steps[index-1].toLowerCase().includes('then')) {
            return { action: 'Verify', expectedResult: content };
          }
          return { action: content, expectedResult: this.generateDefaultExpected(content) };
        }
        // Default format - never return empty expectedResult
        return { action: step, expectedResult: this.generateDefaultExpected(step) };
      });
    }
    
    // If steps is a single string
    if (typeof steps === 'string') {
      return steps.split('\n').filter(s => s.trim()).map(step => ({
        action: step,
        expectedResult: this.generateDefaultExpected(step)
      }));
    }
    
    return [];
  }

  generateAdditionalTestCase(ticket, index) {
    const testScenarios = [
      {
        title: `Data Validation Test ${index}: ${ticket.summary}`,
        objective: `Validate data integrity and field validation for ${ticket.summary}`,
        preconditions: this.extractPreconditions(ticket),
        priority: 'High',
        steps: [
          { action: 'Input valid data in all required fields', expectedResult: 'Data is accepted and validated' },
          { action: 'Attempt to save/submit the data', expectedResult: 'Data is saved successfully' },
          { action: 'Verify data persistence', expectedResult: 'Data is correctly stored and retrievable' },
          { action: 'Check data in related systems', expectedResult: 'Data is consistent across systems' }
        ],
        expectedResult: 'All data validation rules are enforced correctly'
      },
      {
        title: `Error Handling Test ${index}: ${ticket.summary}`,
        objective: `Test error scenarios and recovery for ${ticket.summary}`,
        preconditions: this.extractPreconditions(ticket),
        priority: 'High',
        steps: [
          { action: 'Trigger an error condition', expectedResult: 'Error is detected by the system' },
          { action: 'Verify error message is displayed', expectedResult: 'Clear, actionable error message appears' },
          { action: 'Attempt to recover from error', expectedResult: 'System provides recovery options' },
          { action: 'Retry the operation', expectedResult: 'Operation succeeds after error correction' }
        ],
        expectedResult: 'System handles errors gracefully with proper user feedback'
      },
      {
        title: `Concurrency Test ${index}: ${ticket.summary}`,
        objective: `Test concurrent access and multi-user scenarios for ${ticket.summary}`,
        preconditions: `Multiple test users available. ${this.extractPreconditions(ticket)}`,
        priority: 'Medium',
        steps: [
          { action: 'User 1 accesses the feature', expectedResult: 'Feature loads for User 1' },
          { action: 'User 2 accesses the same feature simultaneously', expectedResult: 'Feature loads for User 2' },
          { action: 'Both users perform operations', expectedResult: 'Operations are handled correctly' },
          { action: 'Verify data consistency', expectedResult: 'No data conflicts or corruption' }
        ],
        expectedResult: 'System handles concurrent access without conflicts'
      },
      {
        title: `Boundary Test ${index}: ${ticket.summary}`,
        objective: `Test boundary conditions and limits for ${ticket.summary}`,
        preconditions: this.extractPreconditions(ticket),
        priority: 'Medium',
        steps: [
          { action: 'Test minimum allowed values', expectedResult: 'Minimum values are handled correctly' },
          { action: 'Test maximum allowed values', expectedResult: 'Maximum values are handled correctly' },
          { action: 'Test just below minimum', expectedResult: 'Appropriate validation error shown' },
          { action: 'Test just above maximum', expectedResult: 'Appropriate validation error shown' }
        ],
        expectedResult: 'All boundary conditions are properly enforced'
      },
      {
        title: `State Transition Test ${index}: ${ticket.summary}`,
        objective: `Verify state transitions and workflow for ${ticket.summary}`,
        preconditions: this.extractPreconditions(ticket),
        priority: 'High',
        steps: [
          { action: 'Start in initial state', expectedResult: 'System is in expected initial state' },
          { action: 'Trigger state transition', expectedResult: 'State changes as expected' },
          { action: 'Verify new state persists', expectedResult: 'State is saved correctly' },
          { action: 'Test reverse transition if applicable', expectedResult: 'Can return to previous state if allowed' }
        ],
        expectedResult: 'All state transitions occur correctly with proper validations'
      },
      {
        title: `Permission Test ${index}: ${ticket.summary}`,
        objective: `Verify access control and permissions for ${ticket.summary}`,
        preconditions: `Users with different permission levels. ${this.extractPreconditions(ticket)}`,
        priority: 'Critical',
        steps: [
          { action: 'Login as admin user', expectedResult: 'Admin has full access' },
          { action: 'Login as regular user', expectedResult: 'Regular user has limited access' },
          { action: 'Attempt restricted action as regular user', expectedResult: 'Action is properly blocked' },
          { action: 'Verify audit logging', expectedResult: 'Access attempts are logged' }
        ],
        expectedResult: 'Permission controls are properly enforced'
      },
      {
        title: `Timeout/Session Test ${index}: ${ticket.summary}`,
        objective: `Test timeout and session handling for ${ticket.summary}`,
        preconditions: this.extractPreconditions(ticket),
        priority: 'Medium',
        steps: [
          { action: 'Start a new session', expectedResult: 'Session is created successfully' },
          { action: 'Let session idle until timeout', expectedResult: 'Session timeout warning appears' },
          { action: 'Attempt action after timeout', expectedResult: 'User is redirected to login' },
          { action: 'Verify data is preserved', expectedResult: 'Unsaved data is recoverable after re-login' }
        ],
        expectedResult: 'Session management works correctly with proper timeout handling'
      },
      {
        title: `Compatibility Test ${index}: ${ticket.summary}`,
        objective: `Test cross-browser/platform compatibility for ${ticket.summary}`,
        preconditions: `Multiple browsers/platforms available. ${this.extractPreconditions(ticket)}`,
        priority: 'High',
        steps: [
          { action: 'Test on primary browser/platform', expectedResult: 'Feature works correctly' },
          { action: 'Test on secondary browsers', expectedResult: 'Feature works consistently' },
          { action: 'Test on mobile devices if applicable', expectedResult: 'Mobile experience is functional' },
          { action: 'Verify UI rendering', expectedResult: 'UI displays correctly across platforms' }
        ],
        expectedResult: 'Feature works consistently across all supported platforms'
      },
      {
        title: `Recovery Test ${index}: ${ticket.summary}`,
        objective: `Test system recovery and resilience for ${ticket.summary}`,
        preconditions: this.extractPreconditions(ticket),
        priority: 'High',
        steps: [
          { action: 'Simulate connection loss during operation', expectedResult: 'System detects connection issue' },
          { action: 'Restore connection', expectedResult: 'System reconnects automatically' },
          { action: 'Verify data integrity', expectedResult: 'No data loss occurred' },
          { action: 'Check operation completion', expectedResult: 'Operation resumes or restarts cleanly' }
        ],
        expectedResult: 'System recovers gracefully from interruptions'
      }
    ];

    // Select a test scenario based on the index to ensure variety (now 9 scenarios after removing localization)
    const scenarioIndex = (index - 1) % testScenarios.length;
    return testScenarios[scenarioIndex];
  }

  generateDefaultExpected(action) {
    const actionLower = action.toLowerCase();
    
    // Navigation actions
    if (actionLower.includes('navigate') || actionLower.includes('go to') || actionLower.includes('open')) {
      if (actionLower.includes('page')) {
        return 'The specified page loads successfully and displays correctly';
      }
      return 'The screen/view loads and displays the expected content';
    }
    
    // Click/Press actions
    if (actionLower.includes('click') || actionLower.includes('tap')) {
      if (actionLower.includes('button')) {
        return 'Button is clicked and responds with visual feedback';
      }
      if (actionLower.includes('link')) {
        return 'Link is activated and navigates to the expected location';
      }
      return 'Element is selected and shows visual feedback';
    }
    
    // Remote control actions
    if (actionLower.includes('press') && (actionLower.includes('right') || actionLower.includes('left') || actionLower.includes('up') || actionLower.includes('down'))) {
      return 'Focus moves to the next element in the specified direction';
    }
    
    // Input actions
    if (actionLower.includes('enter') || actionLower.includes('type') || actionLower.includes('input')) {
      if (actionLower.includes('field')) {
        return 'The text is entered and displayed in the field';
      }
      return 'Input is accepted and displayed correctly';
    }
    
    // Selection actions
    if (actionLower.includes('select') || actionLower.includes('choose')) {
      return 'The option is selected and highlighted';
    }
    
    // Observation actions
    if (actionLower.includes('observe') || actionLower.includes('check') || actionLower.includes('view')) {
      return 'The expected elements and content are visible on the screen';
    }
    
    // Verification actions
    if (actionLower.includes('verify') || actionLower.includes('ensure') || actionLower.includes('confirm')) {
      return 'The condition is verified successfully';
    }
    
    // Wait actions
    if (actionLower.includes('wait') || actionLower.includes('load')) {
      return 'The loading process completes within acceptable time';
    }
    
    // Scroll actions
    if (actionLower.includes('scroll')) {
      return 'The page scrolls to the specified position smoothly';
    }
    
    // Default
    return 'The action completes successfully with expected behavior';
  }
  
  getStepExpectedResult(step) {
    // This is kept for backward compatibility
    return this.generateDefaultExpected(step);
  }

  parseStepsToReproduce(text) {
    if (!text) return [];
    
    // Try to parse numbered steps
    const numberedSteps = text.match(/\d+\.\s+[^\n]+/g);
    if (numberedSteps && numberedSteps.length > 0) {
      return numberedSteps.map(step => step.replace(/^\d+\.\s+/, ''));
    }
    
    // Try to parse bullet points
    const bulletSteps = text.match(/[•\-\*]\s+[^\n]+/g);
    if (bulletSteps && bulletSteps.length > 0) {
      return bulletSteps.map(step => step.replace(/^[•\-\*]\s+/, ''));
    }
    
    // Try to parse line-by-line if it contains action words
    const lines = text.split('\n').filter(line => line.trim());
    const actionWords = ['navigate', 'click', 'enter', 'select', 'open', 'go to', 'type', 'submit', 'press', 'tap'];
    const actionSteps = lines.filter(line => 
      actionWords.some(word => line.toLowerCase().includes(word))
    );
    
    if (actionSteps.length > 0) {
      return actionSteps;
    }
    
    // If no clear steps, return the description split by sentences
    const sentences = text.match(/[^.!?]+[.!?]+/g);
    if (sentences && sentences.length > 1 && sentences.length <= 10) {
      return sentences.map(s => s.trim());
    }
    
    return [];
  }

  extractPreconditions(ticket) {
    // Extract preconditions from various possible sources
    if (ticket.preconditions) {
      return ticket.preconditions;
    }
    
    // Try to extract from description
    const description = ticket.description || '';
    const preconditionMatch = description.match(/precondition[s]?:\s*([^\n]+)/i);
    if (preconditionMatch) {
      return preconditionMatch[1];
    }
    
    // Generate based on ticket context
    if (ticket.type?.toLowerCase() === 'bug') {
      if (description.toLowerCase().includes('login')) {
        return 'User has valid credentials and access to the application';
      }
      if (description.toLowerCase().includes('mobile')) {
        return 'Application is accessible on mobile device with stable internet connection';
      }
      if (description.toLowerCase().includes('api')) {
        return 'API endpoints are accessible and test data is available';
      }
    }
    
    return 'Application is accessible and test environment is properly configured';
  }

  generateBugEdgeCaseSteps(ticket, expectedBehavior) {
    const description = (ticket.description || '').toLowerCase();
    const summary = (ticket.summary || '').toLowerCase();
    const steps = [];
    
    // Test with different data variations
    steps.push(
      { action: 'Test with minimum valid input values', expectedResult: expectedBehavior },
      { action: 'Test with maximum valid input values', expectedResult: expectedBehavior },
      { action: 'Test with special characters if applicable', expectedResult: expectedBehavior }
    );
    
    // Add context-specific edge cases
    if (description.includes('mobile') || summary.includes('mobile')) {
      steps.push(
        { action: 'Test on different mobile browsers (Chrome, Safari, Firefox)', expectedResult: expectedBehavior },
        { action: 'Test with different screen orientations', expectedResult: expectedBehavior },
        { action: 'Test with slow network connection', expectedResult: expectedBehavior }
      );
    }
    
    if (description.includes('login') || summary.includes('login')) {
      steps.push(
        { action: 'Test with recently created account', expectedResult: expectedBehavior },
        { action: 'Test with old existing account', expectedResult: expectedBehavior },
        { action: 'Test rapid login attempts', expectedResult: expectedBehavior },
        { action: 'Test after password reset', expectedResult: expectedBehavior }
      );
    }
    
    if (description.includes('form') || description.includes('submit')) {
      steps.push(
        { action: 'Test with all optional fields empty', expectedResult: expectedBehavior },
        { action: 'Test with all fields filled', expectedResult: expectedBehavior },
        { action: 'Test double-click on submit', expectedResult: 'No duplicate submissions' }
      );
    }
    
    // Always add browser/environment variations
    steps.push(
      { action: 'Test after clearing cache and cookies', expectedResult: expectedBehavior },
      { action: 'Test in incognito/private mode', expectedResult: expectedBehavior }
    );
    
    return steps;
  }

  generateRegressionSteps(ticket, expectedBehavior) {
    const description = (ticket.description || '').toLowerCase();
    const summary = (ticket.summary || '').toLowerCase();
    const steps = [];
    
    // Add context-specific regression tests
    if (description.includes('login') || summary.includes('login')) {
      steps.push(
        { action: 'Test login with different user roles', expectedResult: 'All user types can login successfully' },
        { action: 'Test logout functionality', expectedResult: 'Logout works correctly' },
        { action: 'Test session management', expectedResult: 'Sessions are handled properly' }
      );
    } else if (description.includes('api') || summary.includes('api')) {
      steps.push(
        { action: 'Test API with valid authentication', expectedResult: 'API responds correctly' },
        { action: 'Test API error handling', expectedResult: 'Errors are handled gracefully' },
        { action: 'Test API response times', expectedResult: 'Performance is acceptable' }
      );
    } else if (description.includes('form') || description.includes('input')) {
      steps.push(
        { action: 'Test form validation for all fields', expectedResult: 'Validation rules work correctly' },
        { action: 'Test form submission with valid data', expectedResult: 'Data is saved successfully' },
        { action: 'Test form reset/cancel functionality', expectedResult: 'Form can be cleared/cancelled' }
      );
    } else {
      // Generic regression steps
      steps.push(
        { action: 'Test related features in the same module', expectedResult: 'All related features work normally' },
        { action: 'Verify data persistence after the fix', expectedResult: 'Data is saved and retrieved correctly' },
        { action: 'Check for any console errors or warnings', expectedResult: 'No new errors introduced' }
      );
    }
    
    // Add specific step about the fixed behavior
    steps.unshift({
      action: 'Verify the fixed functionality multiple times',
      expectedResult: `Consistently shows: ${expectedBehavior}`
    });
    
    return steps;
  }

  parseAcceptanceCriteria(text) {
    if (!text) return [];
    
    // Only parse if it looks like explicit acceptance criteria
    const hasAcceptanceHeader = text.toLowerCase().includes('acceptance criteria') || 
                                text.toLowerCase().includes('ac:') ||
                                text.toLowerCase().includes('requirements:');
    
    // Parse bullet points or numbered items ONLY if they look like criteria
    const bullets = text.match(/[•\-\*\d+\.]\s+[^\n]+/g);
    if (bullets && bullets.length > 1) { // Multiple bullet points suggest a list
      const parsedBullets = bullets.map(item => item.replace(/^[•\-\*\d+\.]\s+/, '').trim());
      // Check if these look like acceptance criteria
      const criteriaWords = ['user can', 'user should', 'system should', 'must', 'shall', 'ability to', 'able to'];
      const likelyCriteria = parsedBullets.filter(item => 
        criteriaWords.some(word => item.toLowerCase().includes(word))
      );
      if (likelyCriteria.length >= parsedBullets.length / 2) { // At least half look like criteria
        return parsedBullets;
      }
    }
    
    // If there's an explicit acceptance criteria section, parse it
    if (hasAcceptanceHeader) {
      const lines = text.split('\n').filter(line => line.trim());
      const criteriaWords = ['user can', 'system should', 'must', 'shall', 'ability to', 'able to'];
      const criteria = lines.filter(line => 
        criteriaWords.some(word => line.toLowerCase().includes(word))
      );
      if (criteria.length > 0) {
        return criteria;
      }
    }
    
    return [];
  }

  extractQAValidationScenarios(ticket) {
    const description = ticket.description || '';
    const acceptanceCriteria = ticket.acceptanceCriteria || '';
    const fullText = `${description}\n${acceptanceCriteria}`;
    
    // Look for QA validation section
    const qaPatterns = [
      /QA.*validate.*:([\s\S]*?)(?=\n\n|$)/i,
      /QA.*verify.*:([\s\S]*?)(?=\n\n|$)/i,
      /validation.*scenarios?.*:([\s\S]*?)(?=\n\n|$)/i,
      /test.*scenarios?.*:([\s\S]*?)(?=\n\n|$)/i,
      /scenarios?.*to.*(?:validate|verify|test).*:([\s\S]*?)(?=\n\n|$)/i,
      /(?:validate|verify|test).*on.*prod.*:([\s\S]*?)(?=\n\n|$)/i
    ];
    
    for (const pattern of qaPatterns) {
      const match = fullText.match(pattern);
      if (match && match[1]) {
        // Parse the scenarios from the matched section
        const scenariosText = match[1];
        const scenarios = this.parseScenariosList(scenariosText);
        if (scenarios.length > 0) {
          return scenarios;
        }
      }
    }
    
    // Also check if there's a section that just lists scenarios after certain keywords
    const keywordMatch = fullText.match(/(?:QA|test|validate|verify).*(?:following|these|below|scenarios?).*:([\s\S]*?)(?=\n\n|$)/i);
    if (keywordMatch && keywordMatch[1]) {
      return this.parseScenariosList(keywordMatch[1]);
    }
    
    return [];
  }

  parseScenariosList(text) {
    if (!text) return [];
    
    const scenarios = [];
    
    // Parse numbered items (1. 2. 3. or 1) 2) 3))
    const numberedItems = text.match(/\d+[\)\.]\s*[^\n]+/g);
    if (numberedItems) {
      scenarios.push(...numberedItems.map(item => 
        item.replace(/^\d+[\)\.]\s*/, '').trim()
      ));
    }
    
    // Parse bullet points
    const bulletItems = text.match(/[•\-\*]\s*[^\n]+/g);
    if (bulletItems) {
      scenarios.push(...bulletItems.map(item => 
        item.replace(/^[•\-\*]\s*/, '').trim()
      ));
    }
    
    // If no formatted lists found, try line by line
    if (scenarios.length === 0) {
      const lines = text.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.match(/^(QA|test|validate|verify)/i));
      scenarios.push(...lines);
    }
    
    return scenarios.filter(s => s.length > 5); // Filter out very short items
  }

  generateTestsFromQAScenarios(ticket, qaScenarios, acceptanceCriteria) {
    const testCases = [];
    
    // Generate a test case for each QA scenario
    qaScenarios.forEach((scenario, index) => {
      const steps = this.convertScenarioToSteps(scenario, ticket);
      
      testCases.push({
        title: `QA Validation ${index + 1}: ${this.summarizeScenario(scenario)}`,
        objective: `Validate: ${scenario}`,
        preconditions: this.extractPreconditions(ticket),
        priority: index === 0 ? 'High' : 'Medium',
        steps: steps,
        expectedResult: `Scenario validated successfully: ${scenario}`,
        testData: this.generateTestData(ticket)
      });
    });
    
    // Add acceptance criteria tests if they're different from QA scenarios
    if (acceptanceCriteria.length > 0) {
      const uniqueCriteria = acceptanceCriteria.filter(ac => 
        !qaScenarios.some(qs => qs.toLowerCase().includes(ac.toLowerCase()))
      );
      
      if (uniqueCriteria.length > 0) {
        testCases.push({
          title: `Acceptance Criteria Validation: ${ticket.summary}`,
          objective: `Verify all acceptance criteria are met`,
          preconditions: this.extractPreconditions(ticket),
          priority: 'High',
          steps: uniqueCriteria.map(criterion => ({
            action: this.extractActionFromCriterion(criterion),
            expectedResult: `Criterion met: ${criterion}`
          })),
          expectedResult: `All acceptance criteria satisfied`,
          testData: this.generateTestData(ticket)
        });
      }
    }
    
    // Add edge case testing
    testCases.push({
      testType: 'functional',
          title: `Edge Cases: ${ticket.summary}`,
      objective: `Test boundary conditions and error scenarios`,
      preconditions: this.extractPreconditions(ticket),
      priority: 'Low',
      steps: this.generateEdgeCaseSteps(ticket),
      expectedResult: 'All edge cases handled gracefully',
      testData: this.generateEdgeCaseData(ticket)
    });
    
    return testCases; // Note: This returns an array, not the expected object format
  }

  summarizeScenario(scenario) {
    // Create a short title from the scenario
    const words = scenario.split(' ').slice(0, 6).join(' ');
    return words.length < scenario.length ? `${words}...` : words;
  }

  convertScenarioToSteps(scenario, ticket) {
    const steps = [];
    const scenarioLower = scenario.toLowerCase();
    
    // Parse scenario into actionable steps
    if (scenarioLower.includes('navigate') || scenarioLower.includes('go to')) {
      const match = scenario.match(/(?:navigate|go)\s+(?:to\s+)?([^,\.]+)/i);
      if (match) {
        steps.push({
          action: `Navigate to ${match[1].trim()}`,
          expectedResult: 'Page loads successfully'
        });
      }
    }
    
    // Look for verification points
    if (scenarioLower.includes('verify') || scenarioLower.includes('validate') || scenarioLower.includes('check')) {
      const match = scenario.match(/(?:verify|validate|check)\s+(?:that\s+)?([^,\.]+)/i);
      if (match) {
        steps.push({
          action: `Verify ${match[1].trim()}`,
          expectedResult: match[1].trim()
        });
      }
    }
    
    // Look for user actions
    const actionWords = ['click', 'enter', 'select', 'submit', 'upload', 'download', 'create', 'delete', 'update'];
    actionWords.forEach(action => {
      if (scenarioLower.includes(action)) {
        const pattern = new RegExp(`${action}\\s+(?:on\\s+|the\\s+)?([^,\\.]+)`, 'i');
        const match = scenario.match(pattern);
        if (match) {
          steps.push({
            action: `${action.charAt(0).toUpperCase() + action.slice(1)} ${match[1].trim()}`,
            expectedResult: `${action.charAt(0).toUpperCase() + action.slice(1)} action completed successfully`
          });
        }
      }
    });
    
    // If no specific steps were parsed, create a general validation step
    if (steps.length === 0) {
      steps.push({
        action: `Execute scenario: ${scenario}`,
        expectedResult: 'Scenario executes as described'
      });
      steps.push({
        action: 'Verify the outcome',
        expectedResult: 'Expected behavior is observed'
      });
    }
    
    // Always add a final verification step
    steps.push({
      action: 'Confirm scenario completion',
      expectedResult: `Scenario "${this.summarizeScenario(scenario)}" validated successfully`
    });
    
    return steps;
  }

  generateFeatureSteps(ticket, acceptanceCriteria) {
    const description = (ticket.description || '').toLowerCase();
    const summary = (ticket.summary || '').toLowerCase();
    const fullText = `${summary} ${description}`;
    
    // Generate happy path steps based on acceptance criteria or feature analysis
    const happyPath = [];
    
    if (acceptanceCriteria.length > 0) {
      // Generate steps for each acceptance criterion
      acceptanceCriteria.forEach((criterion, index) => {
        const actionVerb = this.extractActionFromCriterion(criterion);
        happyPath.push({
          action: actionVerb,
          expectedResult: `Acceptance criterion met: ${criterion}`
        });
      });
    } else {
      // Analyze the story content to generate intelligent test scenarios
      const scenarios = this.analyzeStoryContent(ticket);
      if (scenarios.length > 0) {
        happyPath.push(...scenarios);
      } else {
        // Fallback to specific patterns based on feature description
        if (fullText.includes('password reset')) {
        happyPath.push(
          { action: 'Navigate to the password reset page', expectedResult: 'Password reset form is displayed' },
          { action: 'Enter registered email address', expectedResult: 'Email field accepts the input' },
          { action: 'Click "Send Reset Link" button', expectedResult: 'Confirmation message appears' },
          { action: 'Check email for reset link', expectedResult: 'Email with reset link is received' },
          { action: 'Click the reset link in email', expectedResult: 'Password reset page opens with token' },
          { action: 'Enter new password and confirmation', expectedResult: 'Password fields accept input' },
          { action: 'Submit new password', expectedResult: 'Success message appears' },
          { action: 'Login with new password', expectedResult: 'Login successful with new credentials' }
        );
        } else if (fullText.includes('registration') || fullText.includes('sign up')) {
        happyPath.push(
          { action: 'Navigate to registration page', expectedResult: 'Registration form is displayed' },
          { action: 'Enter valid email address', expectedResult: 'Email is accepted' },
          { action: 'Enter password meeting requirements', expectedResult: 'Password strength indicator shows strong' },
          { action: 'Enter matching password confirmation', expectedResult: 'Passwords match' },
          { action: 'Accept terms and conditions', expectedResult: 'Checkbox is selected' },
          { action: 'Submit registration form', expectedResult: 'Account created successfully' },
          { action: 'Verify email confirmation', expectedResult: 'Confirmation email received' }
        );
        } else {
          // Generic feature steps as last resort
          happyPath.push(
            { action: `Navigate to ${ticket.summary} feature`, expectedResult: 'Feature is accessible and loads correctly' },
            { action: 'Review the interface and available options', expectedResult: 'All expected elements are present' },
            { action: 'Enter/select required information', expectedResult: 'Input is accepted and validated' },
            { action: 'Submit/save the changes', expectedResult: 'Operation completes successfully' },
            { action: 'Verify the results', expectedResult: 'Changes are applied correctly' }
          );
        }
      }
    }
    
    // Generate validation steps
    const validation = this.generateValidationSteps(ticket);
    
    // Generate edge case steps
    const edgeCases = this.generateEdgeCaseSteps(ticket);
    
    return { happyPath, validation, edgeCases };
  }

  analyzeStoryContent(ticket) {
    const steps = [];
    const description = ticket.description || '';
    const summary = ticket.summary || '';
    const fullText = `${summary} ${description}`.toLowerCase();
    
    // Extract key features and actions from the story
    const features = this.extractFeatures(fullText);
    const actions = this.extractActions(fullText);
    const entities = this.extractEntities(fullText);
    
    // Build test scenarios based on extracted information
    
    // 1. Navigation/Access scenarios
    if (features.page || features.screen || features.modal || features.dialog) {
      const featureName = features.page || features.screen || features.modal || features.dialog;
      steps.push({
        action: `Navigate to ${featureName}`,
        expectedResult: `${featureName} loads successfully with all elements visible`
      });
    }
    
    // 2. CRUD operation scenarios
    if (actions.create || fullText.includes('add') || fullText.includes('new')) {
      const entity = entities[0] || 'item';
      steps.push(
        { action: `Click on 'Add ${entity}' or 'Create' button`, expectedResult: 'Creation form/modal opens' },
        { action: `Fill in all required fields for ${entity}`, expectedResult: 'Fields accept valid input' },
        { action: 'Submit the creation form', expectedResult: `New ${entity} is created successfully` },
        { action: `Verify ${entity} appears in the list/view`, expectedResult: `${entity} is visible with correct details` }
      );
    }
    
    if (actions.update || actions.edit || fullText.includes('modify')) {
      const entity = entities[0] || 'item';
      steps.push(
        { action: `Select an existing ${entity} to edit`, expectedResult: 'Edit form/mode opens with current data' },
        { action: 'Modify one or more fields', expectedResult: 'Fields are editable and accept new values' },
        { action: 'Save the changes', expectedResult: 'Changes are saved successfully' },
        { action: 'Verify the updates persist', expectedResult: 'Updated values are displayed correctly' }
      );
    }
    
    if (actions.delete || actions.remove) {
      const entity = entities[0] || 'item';
      steps.push(
        { action: `Select ${entity} to delete`, expectedResult: `${entity} is selected` },
        { action: 'Click delete/remove button', expectedResult: 'Confirmation dialog appears' },
        { action: 'Confirm deletion', expectedResult: `${entity} is removed from the system` },
        { action: 'Verify deletion', expectedResult: `${entity} no longer appears in lists/searches` }
      );
    }
    
    if (actions.search || actions.filter || fullText.includes('find')) {
      steps.push(
        { action: 'Enter search criteria', expectedResult: 'Search field accepts input' },
        { action: 'Execute search', expectedResult: 'Search results are displayed' },
        { action: 'Verify search results', expectedResult: 'Results match search criteria' },
        { action: 'Clear search', expectedResult: 'All items are displayed again' }
      );
    }
    
    // 3. Integration scenarios
    if (fullText.includes('integrate') || fullText.includes('connect') || fullText.includes('sync')) {
      steps.push(
        { action: 'Access integration settings', expectedResult: 'Integration options are displayed' },
        { action: 'Configure integration parameters', expectedResult: 'Configuration is accepted' },
        { action: 'Test the integration', expectedResult: 'Connection is successful' },
        { action: 'Verify data flow', expectedResult: 'Data syncs correctly between systems' }
      );
    }
    
    // 4. Permission/Role scenarios
    if (fullText.includes('permission') || fullText.includes('role') || fullText.includes('access')) {
      steps.push(
        { action: 'Test with different user roles', expectedResult: 'Each role sees appropriate options' },
        { action: 'Verify restricted actions', expectedResult: 'Unauthorized actions are blocked' },
        { action: 'Test permission inheritance', expectedResult: 'Permissions cascade correctly' }
      );
    }
    
    // 5. Workflow scenarios
    if (fullText.includes('workflow') || fullText.includes('process') || fullText.includes('approval')) {
      steps.push(
        { action: 'Initiate the workflow', expectedResult: 'Workflow starts successfully' },
        { action: 'Complete first step/stage', expectedResult: 'Workflow advances to next stage' },
        { action: 'Verify notifications sent', expectedResult: 'Appropriate users are notified' },
        { action: 'Complete the workflow', expectedResult: 'Workflow completes with expected outcome' }
      );
    }
    
    // 6. Report/Analytics scenarios
    if (fullText.includes('report') || fullText.includes('analytics') || fullText.includes('dashboard')) {
      steps.push(
        { action: 'Access reporting section', expectedResult: 'Reports/dashboard loads' },
        { action: 'Select date range or filters', expectedResult: 'Filters are applied' },
        { action: 'Generate report', expectedResult: 'Report displays correct data' },
        { action: 'Export report', expectedResult: 'Report exports in selected format' }
      );
    }
    
    // 7. Settings/Configuration scenarios
    if (fullText.includes('setting') || fullText.includes('config') || fullText.includes('preference')) {
      steps.push(
        { action: 'Access settings/configuration', expectedResult: 'Settings page opens' },
        { action: 'Modify configuration values', expectedResult: 'Changes are accepted' },
        { action: 'Save configuration', expectedResult: 'Settings are saved' },
        { action: 'Verify changes take effect', expectedResult: 'System behavior reflects new settings' }
      );
    }
    
    // 8. Notification scenarios
    if (fullText.includes('notification') || fullText.includes('alert') || fullText.includes('email')) {
      steps.push(
        { action: 'Trigger notification event', expectedResult: 'Notification is generated' },
        { action: 'Check notification delivery', expectedResult: 'Notification received by correct recipients' },
        { action: 'Verify notification content', expectedResult: 'Content is accurate and complete' },
        { action: 'Test notification preferences', expectedResult: 'User preferences are respected' }
      );
    }
    
    return steps;
  }

  extractFeatures(text) {
    const features = {};
    
    // Look for UI components
    if (text.includes('page')) features.page = text.match(/([\w\s]+)\s+page/)?.[1]?.trim() || 'the page';
    if (text.includes('screen')) features.screen = text.match(/([\w\s]+)\s+screen/)?.[1]?.trim() || 'the screen';
    if (text.includes('modal')) features.modal = text.match(/([\w\s]+)\s+modal/)?.[1]?.trim() || 'the modal';
    if (text.includes('dialog')) features.dialog = text.match(/([\w\s]+)\s+dialog/)?.[1]?.trim() || 'the dialog';
    if (text.includes('form')) features.form = text.match(/([\w\s]+)\s+form/)?.[1]?.trim() || 'the form';
    
    return features;
  }

  extractActions(text) {
    const actions = {};
    
    // CRUD operations
    if (text.includes('create') || text.includes('add') || text.includes('new')) actions.create = true;
    if (text.includes('read') || text.includes('view') || text.includes('display')) actions.read = true;
    if (text.includes('update') || text.includes('edit') || text.includes('modify')) actions.update = true;
    if (text.includes('delete') || text.includes('remove')) actions.delete = true;
    
    // Other common actions
    if (text.includes('search') || text.includes('find')) actions.search = true;
    if (text.includes('filter')) actions.filter = true;
    if (text.includes('sort')) actions.sort = true;
    if (text.includes('export')) actions.export = true;
    if (text.includes('import')) actions.import = true;
    if (text.includes('upload')) actions.upload = true;
    if (text.includes('download')) actions.download = true;
    
    return actions;
  }

  isEdenTicket(ticket) {
    const summary = (ticket.summary || '').toLowerCase();
    const description = (ticket.description || '').toLowerCase();
    
    // Check if title contains 'eden' or description mentions Eden-specific patterns
    return summary.includes('eden') || 
           description.includes('eden') || 
           description.includes('ui://') || 
           description.includes('{{ui://') ||
           description.includes('confluence.paramount.tech');
  }

  generateEdenTestCases(ticket, options = {}) {
    const { style = 'BDD' } = options;
    const testCases = [];
    
    if (ticket.type?.toLowerCase() === 'bug') {
      // Eden bug - focus on log validation
      const logEvents = this.extractEdenLogEvents(ticket.description);
      const uiReferences = this.extractEdenUIReferences(ticket.description);
      
      testCases.push({
        title: `Eden Bug Validation: ${ticket.summary}`,
        objective: `Validate Eden events and logs match expected patterns for ${ticket.summary}`,
        preconditions: 'Eden environment accessible, test user configured with appropriate subscription',
        priority: 'High',
        steps: [
          { action: 'Access Eden dashboard/admin panel', expectedResult: 'Eden interface loads successfully' },
          { action: 'Navigate to the affected Eden feature/flow', expectedResult: 'Feature is accessible' },
          { action: 'Perform the steps described in the ticket', expectedResult: 'Actions execute without errors' },
          { action: 'Open developer console and network tab', expectedResult: 'Console and network monitoring active' },
          { action: 'Trigger the Eden event/action', expectedResult: 'Event fires and is captured in logs' },
          { action: 'Review Eden event logs', expectedResult: 'Event structure matches expected format' },
          ...logEvents.map(event => ({
            action: `Verify log event: ${event}`,
            expectedResult: `Event "${event}" is present in logs with correct data`
          })),
          { action: 'Compare actual vs expected event payloads', expectedResult: 'Payloads match the documented structure' },
          { action: 'Validate UI state after event', expectedResult: 'UI reflects the correct state based on event' }
        ],
        expectedResult: 'All Eden events fire correctly with expected payloads and UI updates appropriately',
        testData: {
          subscription: 'Essential Yearly',
          ...this.parseEdenTestData(uiReferences)
        },
        notes: uiReferences.length > 0 ? 
          `⚠️ Eden UI References found: ${uiReferences.join(', ')}. Manual verification required.` : 
          undefined
      });
      
      // Add regression test for Eden
      testCases.push({
        title: `Eden Regression Test: ${ticket.summary}`,
        objective: 'Ensure Eden fix doesn\'t break other subscription flows',
        preconditions: 'Multiple test accounts with different subscription types',
        priority: 'Medium',
        steps: [
          { action: 'Test with Essential Monthly subscription', expectedResult: 'Flow works correctly' },
          { action: 'Test with Essential Yearly subscription', expectedResult: 'Flow works correctly' },
          { action: 'Test with Premium Monthly subscription', expectedResult: 'Flow works correctly' },
          { action: 'Test with Premium Yearly subscription', expectedResult: 'Flow works correctly' },
          { action: 'Test upgrade flow', expectedResult: 'Upgrade completes successfully' },
          { action: 'Test downgrade flow', expectedResult: 'Downgrade completes successfully' },
          { action: 'Verify all Eden events fire correctly', expectedResult: 'Events match expected patterns' }
        ],
        expectedResult: 'All subscription flows work correctly without regression'
      });
    } else {
      // Eden story - likely has Confluence references
      const confluenceRefs = this.extractConfluenceReferences(ticket.description);
      
      testCases.push({
        title: `Eden Feature Validation: ${ticket.summary}`,
        objective: `Validate Eden feature implementation according to specifications`,
        preconditions: 'Eden environment configured, test accounts with various subscription states',
        priority: 'High',
        steps: [
          { action: 'Review Eden feature requirements', expectedResult: 'Requirements understood' },
          { action: 'Access Eden feature in test environment', expectedResult: 'Feature is accessible' },
          { action: 'Test primary Eden flow', expectedResult: 'Flow completes successfully' },
          { action: 'Verify Eden events fire correctly', expectedResult: 'All events captured with correct data' },
          { action: 'Test with different subscription tiers', expectedResult: 'Feature behaves correctly for each tier' },
          { action: 'Validate UI components render correctly', expectedResult: 'All Eden UI elements display properly' },
          { action: 'Test error scenarios', expectedResult: 'Errors handled gracefully' },
          { action: 'Verify analytics events', expectedResult: 'Analytics capture correct Eden data' }
        ],
        expectedResult: 'Eden feature works as specified in requirements',
        notes: confluenceRefs.length > 0 ? 
          `⚠️ Confluence documentation references found but not accessible: ${confluenceRefs.join(', ')}. Please review documentation manually.` :
          '⚠️ Eden story - please review Confluence documentation for detailed requirements.'
      });
      
      // Add Eden-specific edge cases
      testCases.push({
        title: `Eden Edge Cases: ${ticket.summary}`,
        objective: 'Test Eden feature with various edge cases and subscription states',
        preconditions: 'Test accounts in various states (trial, expired, cancelled, etc.)',
        priority: 'Medium',
        steps: [
          { action: 'Test with trial account', expectedResult: 'Appropriate trial limitations applied' },
          { action: 'Test with expired subscription', expectedResult: 'Expiry handled correctly' },
          { action: 'Test with cancelled subscription', expectedResult: 'Cancellation state reflected' },
          { action: 'Test during plan transition', expectedResult: 'Transition handled smoothly' },
          { action: 'Test with payment failure state', expectedResult: 'Payment issues handled gracefully' },
          { action: 'Test concurrent Eden events', expectedResult: 'Events don\'t conflict' },
          { action: 'Test Eden feature in different locales', expectedResult: 'Localization works correctly' }
        ],
        expectedResult: 'All edge cases handled appropriately'
      });
    }
    
    return { testCases, style };
  }

  extractEdenLogEvents(description) {
    const events = [];
    
    // Look for common Eden event patterns
    const eventPatterns = [
      /event[:\s]+([\w_]+)/gi,
      /"event"[:\s]+"([\w_]+)"/gi,
      /Eden\.track\(['"]([\w_]+)['"]/gi,
      /analytics\.track\(['"]([\w_]+)['"]/gi
    ];
    
    eventPatterns.forEach(pattern => {
      const matches = description.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) events.push(match[1]);
      }
    });
    
    // Also look for specific Eden events mentioned in text
    const commonEdenEvents = [
      'subscription_started', 'subscription_cancelled', 'subscription_upgraded',
      'subscription_downgraded', 'payment_succeeded', 'payment_failed',
      'trial_started', 'trial_ended', 'plan_selected', 'billing_updated'
    ];
    
    commonEdenEvents.forEach(event => {
      if (description.includes(event)) {
        events.push(event);
      }
    });
    
    return [...new Set(events)]; // Remove duplicates
  }

  extractEdenUIReferences(description) {
    const refs = [];
    
    // Match Eden UI reference patterns
    const patterns = [
      /{{ui:\/\/[^}]+}}/g,
      /ui:\/\/[\w\-\/]+/g
    ];
    
    patterns.forEach(pattern => {
      const matches = description.match(pattern);
      if (matches) {
        refs.push(...matches);
      }
    });
    
    return refs;
  }

  extractConfluenceReferences(description) {
    const refs = [];
    
    // Match Confluence URLs
    const confluencePattern = /https?:\/\/confluence\.paramount\.tech[^\s]+/g;
    const matches = description.match(confluencePattern);
    
    if (matches) {
      refs.push(...matches);
    }
    
    return refs;
  }

  parseEdenTestData(uiReferences) {
    const testData = {};
    
    // Parse UI references to extract test data hints
    uiReferences.forEach(ref => {
      if (ref.includes('payment-option')) {
        if (ref.includes('annual')) testData.billingPeriod = 'annual';
        if (ref.includes('monthly')) testData.billingPeriod = 'monthly';
        if (ref.includes('essential')) testData.planTier = 'essential';
        if (ref.includes('premium')) testData.planTier = 'premium';
      }
    });
    
    // Add default Eden test data
    testData.testEmail = 'eden.test@paramount.com';
    testData.testCard = '4111111111111111';
    testData.zipCode = '10001';
    
    return testData;
  }

  generateTestsFromConfluenceScenarios(ticket, options = {}) {
    const { style = 'BDD' } = options;
    const testCases = [];
    
    logger.info(`Generating test cases from ${ticket.confluenceScenarios.length} Confluence scenarios`);
    
    // Generate test cases from Confluence scenarios
    ticket.confluenceScenarios.forEach((scenario, index) => {
      const steps = this.convertScenarioToDetailedSteps(scenario, ticket);
      
      testCases.push({
        title: `Confluence Test ${index + 1}: ${this.summarizeScenario(scenario)}`,
        objective: `Validate documented scenario: ${scenario}`,
        preconditions: this.extractPreconditions(ticket),
        priority: index < 3 ? 'High' : 'Medium', // First 3 are high priority
        steps: steps,
        expectedResult: `Scenario completes as documented in Confluence`,
        testData: this.generateTestData(ticket),
        source: 'Confluence Documentation'
      });
    });
    
    // Add technical spec validation if available
    if (ticket.technicalSpecs) {
      if (ticket.technicalSpecs.endpoints?.length > 0) {
        testCases.push({
          title: 'API Endpoint Validation',
          objective: 'Verify all documented API endpoints work correctly',
          preconditions: 'API access configured, test data prepared',
          priority: 'High',
          steps: ticket.technicalSpecs.endpoints.map(ep => ({
            action: `Test ${ep.method} ${ep.path}`,
            expectedResult: 'Endpoint responds with correct status and data structure'
          })),
          expectedResult: 'All API endpoints function as documented'
        });
      }
      
      if (ticket.technicalSpecs.uiElements?.length > 0) {
        testCases.push({
          title: 'UI Element Validation',
          objective: 'Verify all documented UI elements are present and functional',
          preconditions: 'Application UI accessible',
          priority: 'Medium',
          steps: ticket.technicalSpecs.uiElements.map(element => ({
            action: `Locate and interact with "${element}"`,
            expectedResult: `"${element}" is visible and responds to interaction`
          })),
          expectedResult: 'All UI elements match documentation'
        });
      }
    }
    
    // Add standard edge cases
    testCases.push({
      testType: 'functional',
          title: `Edge Cases: ${ticket.summary}`,
      objective: 'Test boundary conditions beyond documented scenarios',
      preconditions: this.extractPreconditions(ticket),
      priority: 'Low',
      steps: this.generateEdgeCaseSteps(ticket),
      expectedResult: 'System handles edge cases gracefully'
    });
    
    return { testCases, style };
  }

  convertScenarioToDetailedSteps(scenario, ticket) {
    const steps = [];
    const scenarioLower = scenario.toLowerCase();
    
    // Handle Given/When/Then format
    if (scenarioLower.includes('given') || scenarioLower.includes('when') || scenarioLower.includes('then')) {
      const gwtParts = scenario.split(/(?=given|when|then)/i);
      gwtParts.forEach(part => {
        const trimmed = part.trim();
        if (trimmed) {
          if (trimmed.toLowerCase().startsWith('given')) {
            steps.push({
              action: `Setup: ${trimmed.substring(5).trim()}`,
              expectedResult: 'Precondition established'
            });
          } else if (trimmed.toLowerCase().startsWith('when')) {
            steps.push({
              action: trimmed.substring(4).trim(),
              expectedResult: 'Action performed successfully'
            });
          } else if (trimmed.toLowerCase().startsWith('then')) {
            steps.push({
              action: 'Verify result',
              expectedResult: trimmed.substring(4).trim()
            });
          }
        }
      });
    } else {
      // Parse as regular scenario
      const parsed = this.convertScenarioToSteps(scenario, ticket);
      steps.push(...parsed);
    }
    
    return steps.length > 0 ? steps : [{
      action: `Execute: ${scenario}`,
      expectedResult: 'Scenario completes as documented'
    }];
  }

  extractEntities(text) {
    const entities = [];
    
    // Common entities in software
    const commonEntities = [
      'user', 'profile', 'account', 'customer', 'client',
      'product', 'item', 'order', 'invoice', 'payment',
      'document', 'file', 'report', 'message', 'notification',
      'task', 'ticket', 'issue', 'project', 'team',
      'role', 'permission', 'group', 'category', 'tag'
    ];
    
    commonEntities.forEach(entity => {
      if (text.includes(entity)) {
        entities.push(entity);
      }
    });
    
    // Also look for custom entities (capitalized words that might be entities)
    const capitalizedWords = text.match(/[A-Z][a-z]+/g);
    if (capitalizedWords) {
      entities.push(...capitalizedWords.filter(word => 
        !['The', 'This', 'That', 'When', 'Where', 'What', 'How'].includes(word)
      ));
    }
    
    return [...new Set(entities)]; // Remove duplicates
  }

  extractActionFromCriterion(criterion) {
    // Convert acceptance criterion to actionable step
    const lowerCriterion = criterion.toLowerCase();
    
    if (lowerCriterion.includes('user can')) {
      return criterion.replace(/user can/i, 'Verify that user can');
    }
    if (lowerCriterion.includes('system should')) {
      return criterion.replace(/system should/i, 'Verify that system');
    }
    if (lowerCriterion.includes('must')) {
      return `Verify that ${criterion}`;
    }
    
    return `Test: ${criterion}`;
  }

  generateValidationSteps(ticket) {
    const description = (ticket.description || '').toLowerCase();
    const steps = [];
    
    if (description.includes('email')) {
      steps.push(
        { action: 'Enter invalid email format', expectedResult: 'Email validation error appears' },
        { action: 'Enter email without domain', expectedResult: 'Invalid email error shown' }
      );
    }
    
    if (description.includes('password')) {
      steps.push(
        { action: 'Enter password below minimum length', expectedResult: 'Password too short error' },
        { action: 'Enter password without required characters', expectedResult: 'Password complexity error' }
      );
    }
    
    if (description.includes('date') || description.includes('time')) {
      steps.push(
        { action: 'Enter invalid date format', expectedResult: 'Date format error appears' },
        { action: 'Enter date in the past (if not allowed)', expectedResult: 'Invalid date range error' }
      );
    }
    
    // Always add generic validation
    steps.push(
      { action: 'Leave all required fields empty', expectedResult: 'Required field errors appear' },
      { action: 'Enter data exceeding maximum length', expectedResult: 'Maximum length error shown' },
      { action: 'Submit form with validation errors', expectedResult: 'Form submission is prevented' },
      { action: 'Correct all validation errors', expectedResult: 'Errors clear when fixed' }
    );
    
    return steps;
  }

  generateEdgeCaseSteps(ticket) {
    const description = (ticket.description || '').toLowerCase();
    const steps = [];
    
    // Add context-specific edge cases
    if (description.includes('upload') || description.includes('file')) {
      steps.push(
        { action: 'Upload file at maximum size limit', expectedResult: 'File is accepted' },
        { action: 'Upload file slightly over limit', expectedResult: 'File size error shown' },
        { action: 'Upload unsupported file type', expectedResult: 'File type error shown' },
        { action: 'Upload multiple files simultaneously', expectedResult: 'All files processed correctly' }
      );
    }
    
    if (description.includes('search')) {
      steps.push(
        { action: 'Search with special characters', expectedResult: 'Search handles special chars correctly' },
        { action: 'Search with very long query', expectedResult: 'Query is truncated appropriately' },
        { action: 'Search with no results', expectedResult: 'No results message shown' },
        { action: 'Search with SQL injection attempt', expectedResult: 'Input is sanitized safely' }
      );
    }
    
    // Generic edge cases
    steps.push(
      { action: 'Test with minimum valid values', expectedResult: 'Minimum values accepted' },
      { action: 'Test with maximum valid values', expectedResult: 'Maximum values handled' },
      { action: 'Test with unicode and emoji characters', expectedResult: 'Special characters handled' },
      { action: 'Test rapid successive submissions', expectedResult: 'Duplicate prevention works' },
      { action: 'Test browser back/forward navigation', expectedResult: 'State maintained correctly' }
    );
    
    return steps;
  }

  generateTestData(ticket) {
    const description = (ticket.description || '').toLowerCase();
    const data = {};
    
    if (description.includes('email')) {
      data.validEmail = 'test.user@example.com';
      data.alternateEmail = 'alternate.user@test.org';
    }
    
    if (description.includes('password')) {
      data.validPassword = 'SecureP@ss123!';
      data.newPassword = 'NewSecure#456';
    }
    
    if (description.includes('phone')) {
      data.validPhone = '+1-555-123-4567';
      data.alternatePhone = '555-987-6543';
    }
    
    if (description.includes('name') || description.includes('user')) {
      data.firstName = 'Test';
      data.lastName = 'User';
      data.username = 'testuser123';
    }
    
    if (description.includes('date')) {
      data.validDate = new Date().toISOString().split('T')[0];
      data.futureDate = new Date(Date.now() + 86400000).toISOString().split('T')[0];
    }
    
    // Add generic test data if nothing specific
    if (Object.keys(data).length === 0) {
      data.testInput = 'Test Value 123';
      data.description = 'Test description for QA testing';
      data.id = 'TEST-' + Date.now();
    }
    
    return data;
  }

  generateInvalidTestData(ticket) {
    const description = (ticket.description || '').toLowerCase();
    const data = {};
    
    if (description.includes('email')) {
      data.invalidEmail = 'not-an-email';
      data.malformedEmail = '@example.com';
      data.missingDomain = 'user@';
    }
    
    if (description.includes('password')) {
      data.shortPassword = '123';
      data.weakPassword = 'password';
      data.noSpecialChars = 'Password123';
    }
    
    if (description.includes('phone')) {
      data.invalidPhone = '123';
      data.tooLongPhone = '123456789012345678901';
    }
    
    if (description.includes('date')) {
      data.invalidDate = '2024-13-45';
      data.wrongFormat = '45/13/2024';
      data.textDate = 'yesterday';
    }
    
    // Generic invalid data
    data.emptyString = '';
    data.nullValue = null;
    data.tooLongText = 'x'.repeat(1000);
    data.sqlInjection = "'; DROP TABLE users; --";
    data.scriptInjection = '<script>alert("XSS")</script>';
    
    return data;
  }

  generateEdgeCaseData(ticket) {
    return {
      minValue: 0,
      maxValue: 2147483647, // Max 32-bit integer
      minLength: 'a',
      maxLength: 'x'.repeat(255),
      specialChars: '!@#$%^&*()_+-=[]{}|;:\'"<>,.?/',
      unicode: '测试数据 🎯🚀🎉',
      whitespace: '   test   ',
      lineBreaks: 'line1\nline2\rline3',
      htmlEntities: '&lt;&gt;&amp;&quot;',
      zeroValues: [0, 0.0, '0', false],
      boundaryDates: {
        minDate: '1900-01-01',
        maxDate: '2099-12-31',
        leapYear: '2024-02-29'
      }
    };
  }

  async analyzeDuplicate(testCase, existingTestCases) {
    if (!this.model) {
      throw new Error('Gemini API not configured');
    }

    const prompt = `Analyze if this test case is a duplicate of any existing test cases.
    
New Test Case:
${JSON.stringify(testCase, null, 2)}

Existing Test Cases:
${JSON.stringify(existingTestCases, null, 2)}

Return a JSON object with:
- isDuplicate: boolean
- similarityScore: number (0-100)
- similarTestCases: array of IDs of similar test cases
- recommendation: string`;

    try {
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      return JSON.parse(text);
    } catch (error) {
      logger.error('Duplicate analysis error:', error);
      return {
        isDuplicate: false,
        similarityScore: 0,
        similarTestCases: [],
        recommendation: 'Unable to analyze'
      };
    }
  }

  /**
   * Generate automation code using Gemini AI
   */
  async generateAutomationCode(prompt, options = {}) {
    if (!this.model) {
      logger.warn('Gemini API not configured for automation generation');
      // Return a basic structure
      return {
        code: '// Gemini API not configured',
        className: 'GeneratedTest',
        packageName: 'com.example.tests',
        fileName: 'GeneratedTest.java'
      };
    }

    try {
      logger.info('Generating automation code with Gemini AI');
      
      // Add specific instructions for code generation
      const enhancedPrompt = prompt + `

OUTPUT FORMAT:
==============
Generate ONLY the Java code without any markdown formatting or explanations.
The code should be complete and ready to compile.
Include all necessary imports.
Do not wrap the code in markdown code blocks.
Start directly with the package declaration.`;

      const result = await this.model.generateContent(enhancedPrompt);
      const response = await result.response;
      const generatedCode = response.text();
      
      // Clean up the generated code
      let cleanedCode = generatedCode;
      
      // Remove markdown code blocks if present
      if (cleanedCode.includes('```java')) {
        cleanedCode = cleanedCode.replace(/```java\n?/g, '').replace(/```\n?/g, '');
      }
      
      // Extract class name from the code
      const classNameMatch = cleanedCode.match(/public\s+class\s+(\w+)/);
      const className = classNameMatch ? classNameMatch[1] : 'GeneratedTest';
      
      // Extract package name from the code
      const packageMatch = cleanedCode.match(/package\s+([\w.]+);/);
      const packageName = packageMatch ? packageMatch[1] : 'com.example.tests';
      
      logger.info(`Generated test class: ${className} in package ${packageName}`);
      
      return {
        code: cleanedCode,
        className,
        packageName,
        fileName: `${className}.java`,
        usedGemini: true,
        elementPatternsUsed: options.elementPatterns ? true : false
      };
    } catch (error) {
      logger.error('Error generating automation code with Gemini:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const geminiService = new GeminiService();
export default geminiService;
