/**
 * Test Composer Agent
 *
 * Assembles all pieces from the pipeline into a complete, runnable test class:
 * - Combines scenario, prerequisites, and method mappings
 * - Generates proper Java/TestNG structure
 * - Applies code patterns from existing tests
 * - Adds appropriate annotations and documentation
 *
 * @see /docs/architecture/multi-agent-test-generation-architecture.md
 */

import { logger } from '../utils/logger.js';

class TestComposerAgent {
  constructor() {
    // Default package structure
    this.defaultPackage = 'com.example.tests';

    // TestNG annotation imports
    this.standardImports = [
      'org.testng.annotations.Test',
      'org.testng.annotations.BeforeMethod',
      'org.testng.annotations.AfterMethod',
      'org.testng.Assert'
    ];

    // Code style settings
    this.codeStyle = {
      indent: '    ', // 4 spaces
      lineWidth: 120,
      addJavadoc: true,
      addTimestamp: true
    };
  }

  /**
   * Initialize the agent
   */
  async initialize() {
    logger.info('TestComposerAgent initialized');
  }

  /**
   * Compose a complete test class from pipeline outputs
   *
   * @param {Object} scenario - Original scenario with title and description
   * @param {Object} decomposition - Output from ScenarioDecomposerAgent
   * @param {Object} mappingResult - Output from ActionMapperAgent
   * @param {Object} prerequisites - Output from PrerequisiteBuilderAgent
   * @param {Object} options - Generation options
   * @returns {Object} Complete test class code and metadata
   */
  async composeTest(scenario, decomposition, mappingResult, prerequisites, options = {}) {
    const {
      className = null,
      packageName = this.defaultPackage,
      platform = null,
      brand = null,
      testType = 'functional',
      includeComments = true
    } = options;

    // Generate class name if not provided
    const finalClassName = className || this.generateClassName(scenario.title, testType);

    // Build the test code
    const code = this.buildTestClass({
      packageName,
      className: finalClassName,
      scenario,
      decomposition,
      mappingResult,
      prerequisites,
      platform,
      brand,
      testType,
      includeComments
    });

    // Generate metadata
    const metadata = this.generateMetadata({
      className: finalClassName,
      scenario,
      mappingResult,
      prerequisites,
      testType,
      platform,
      brand
    });

    return {
      success: true,
      code,
      metadata,
      className: finalClassName,
      packageName,
      fullClassName: `${packageName}.${finalClassName}`,
      unmappedActions: mappingResult.unmapped || [],
      warnings: this.generateWarnings(mappingResult, prerequisites)
    };
  }

  /**
   * Generate class name from scenario title
   */
  generateClassName(title, testType) {
    // Clean and convert to PascalCase
    const cleaned = title
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .split(/\s+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');

    // Add Test suffix if not present
    const suffix = testType === 'smoke' ? 'SmokeTest' : 'Test';
    return cleaned.endsWith('Test') ? cleaned : `${cleaned}${suffix}`;
  }

  /**
   * Build complete test class code
   */
  buildTestClass(params) {
    const {
      packageName,
      className,
      scenario,
      decomposition,
      mappingResult,
      prerequisites,
      platform,
      brand,
      testType,
      includeComments
    } = params;

    const lines = [];
    const indent = this.codeStyle.indent;

    // Package declaration
    lines.push(`package ${packageName};`);
    lines.push('');

    // Imports
    lines.push(...this.generateImports(mappingResult, prerequisites));
    lines.push('');

    // Class JavaDoc
    if (includeComments) {
      lines.push('/**');
      lines.push(` * Test: ${scenario.title}`);
      if (scenario.description) {
        lines.push(` * ${scenario.description}`);
      }
      lines.push(' *');
      lines.push(` * Test Type: ${testType}`);
      if (platform) lines.push(` * Platform: ${platform}`);
      if (brand) lines.push(` * Brand: ${brand}`);
      lines.push(' *');
      lines.push(' * Generated by QA-Copilot Multi-Agent System');
      if (this.codeStyle.addTimestamp) {
        lines.push(` * Generated on: ${new Date().toISOString()}`);
      }
      lines.push(' */');
    }

    // Class declaration
    lines.push(`public class ${className} extends BaseTest {`);
    lines.push('');

    // Instance variables for screens
    lines.push(...this.generateInstanceVariables(mappingResult, prerequisites, indent));
    lines.push('');

    // @BeforeMethod
    lines.push(...this.generateBeforeMethod(prerequisites, indent, includeComments));
    lines.push('');

    // Main test method
    lines.push(...this.generateTestMethod(scenario, decomposition, mappingResult, indent, includeComments));
    lines.push('');

    // @AfterMethod (optional cleanup)
    lines.push(...this.generateAfterMethod(indent, includeComments));

    // Close class
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate import statements
   */
  generateImports(mappingResult, prerequisites) {
    const imports = new Set(this.standardImports);

    // Add screen imports
    if (prerequisites?.prerequisites?.imports) {
      for (const imp of prerequisites.prerequisites.imports) {
        if (!imp.startsWith('org.') && !imp.startsWith('java.')) {
          imports.add(`com.example.screens.${imp}`);
        } else {
          imports.add(imp);
        }
      }
    }

    // Add BaseTest
    imports.add('com.example.base.BaseTest');

    // Sort and format
    const sorted = Array.from(imports).sort();
    return sorted.map(imp => `import ${imp};`);
  }

  /**
   * Generate instance variable declarations
   */
  generateInstanceVariables(mappingResult, prerequisites, indent) {
    const lines = [];
    const screens = new Set();

    // Collect unique screens
    if (prerequisites?.screenChain) {
      prerequisites.screenChain.forEach(s => screens.add(s));
    }
    if (mappingResult?.mappings) {
      mappingResult.mappings.forEach(m => {
        if (m.className) screens.add(m.className);
      });
    }

    // Generate declarations
    for (const screen of screens) {
      if (screen !== 'BaseTest') {
        const varName = screen.charAt(0).toLowerCase() + screen.slice(1);
        lines.push(`${indent}private ${screen} ${varName};`);
      }
    }

    return lines;
  }

  /**
   * Generate @BeforeMethod
   */
  generateBeforeMethod(prerequisites, indent, includeComments) {
    const lines = [];

    if (includeComments) {
      lines.push(`${indent}/**`);
      lines.push(`${indent} * Test setup - launches app and navigates to target screen`);
      lines.push(`${indent} */`);
    }

    lines.push(`${indent}@BeforeMethod`);
    lines.push(`${indent}public void setUp() {`);

    // Initialize screens
    const screens = new Set();
    if (prerequisites?.screenChain) {
      prerequisites.screenChain.forEach(s => screens.add(s));
    }

    for (const screen of screens) {
      if (screen !== 'BaseTest') {
        const varName = screen.charAt(0).toLowerCase() + screen.slice(1);
        lines.push(`${indent}${indent}${varName} = new ${screen}(driver);`);
      }
    }

    lines.push('');

    // Setup sequence
    if (prerequisites?.prerequisites?.setupSequence) {
      for (const step of prerequisites.prerequisites.setupSequence) {
        const comment = includeComments ? ` // ${step.description}` : '';
        const code = this.generateMethodCall(step);
        lines.push(`${indent}${indent}${code}${comment}`);
      }
    }

    // Navigation to target
    if (prerequisites?.prerequisites?.navigationToTarget) {
      lines.push('');
      if (includeComments) {
        lines.push(`${indent}${indent}// Navigate to target screen`);
      }
      for (const navStep of prerequisites.prerequisites.navigationToTarget) {
        const varName = navStep.class.charAt(0).toLowerCase() + navStep.class.slice(1);
        lines.push(`${indent}${indent}${varName}.${navStep.method}();`);
      }
    }

    lines.push(`${indent}}`);
    return lines;
  }

  /**
   * Generate main test method
   */
  generateTestMethod(scenario, decomposition, mappingResult, indent, includeComments) {
    const lines = [];

    // Method JavaDoc
    if (includeComments) {
      lines.push(`${indent}/**`);
      lines.push(`${indent} * ${scenario.title}`);
      if (scenario.description) {
        lines.push(`${indent} * <p>${scenario.description}</p>`);
      }
      lines.push(`${indent} */`);
    }

    // @Test annotation
    const testDescription = scenario.title.replace(/"/g, '\\"');
    lines.push(`${indent}@Test(description = "${testDescription}")`);

    // Method signature
    const methodName = this.generateMethodName(scenario.title);
    lines.push(`${indent}public void ${methodName}() {`);

    // Test steps
    const steps = mappingResult?.mappings || decomposition?.steps || [];

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];

      // Skip prerequisites (handled in setup)
      if (step.isPrerequisite) continue;

      // Add step comment
      if (includeComments) {
        const stepNum = i + 1;
        const description = step.details || step.action || 'Execute step';
        lines.push(`${indent}${indent}// Step ${stepNum}: ${description}`);
      }

      // Generate method call
      if (step.status === 'found' || step.methodName) {
        const code = this.generateStepCode(step);
        lines.push(`${indent}${indent}${code}`);
      } else if (step.action) {
        // Unmapped action - generate TODO
        lines.push(`${indent}${indent}// TODO: Implement action - ${step.action} ${step.target || ''}`);
      }

      // Add blank line between steps
      if (i < steps.length - 1 && includeComments) {
        lines.push('');
      }
    }

    lines.push(`${indent}}`);
    return lines;
  }

  /**
   * Generate @AfterMethod
   */
  generateAfterMethod(indent, includeComments) {
    const lines = [];

    if (includeComments) {
      lines.push(`${indent}/**`);
      lines.push(`${indent} * Test cleanup`);
      lines.push(`${indent} */`);
    }

    lines.push(`${indent}@AfterMethod`);
    lines.push(`${indent}public void tearDown() {`);
    lines.push(`${indent}${indent}// Cleanup handled by BaseTest`);
    lines.push(`${indent}}`);

    return lines;
  }

  /**
   * Generate method name from title
   */
  generateMethodName(title) {
    const cleaned = title
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .split(/\s+/)
      .map((word, idx) =>
        idx === 0
          ? word.toLowerCase()
          : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      )
      .join('');

    return `test${cleaned.charAt(0).toUpperCase() + cleaned.slice(1)}`;
  }

  /**
   * Generate method call for a setup step
   */
  generateMethodCall(step) {
    const params = step.params?.join(', ') || '';

    if (step.class === 'BaseTest') {
      return `${step.method}(${params});`;
    }

    const varName = step.class.charAt(0).toLowerCase() + step.class.slice(1);
    return `${varName}.${step.method}(${params});`;
  }

  /**
   * Generate code for a test step
   */
  generateStepCode(step) {
    const className = step.className || step.class;
    const methodName = step.methodName || step.method;

    if (!className || !methodName) {
      return `// Unable to generate code for: ${step.action || 'unknown action'}`;
    }

    const varName = className.charAt(0).toLowerCase() + className.slice(1);

    // Handle parameters
    let params = '';
    if (step.parameters && step.parameters.length > 0) {
      params = this.inferParameterValues(step);
    }

    return `${varName}.${methodName}(${params});`;
  }

  /**
   * Infer parameter values from step context
   */
  inferParameterValues(step) {
    const params = [];

    for (const param of step.parameters) {
      if (param.includes('String')) {
        // String parameter - use placeholder or inferred value
        if (step.details) {
          params.push(`"${step.details}"`);
        } else {
          params.push('"testValue"');
        }
      } else if (param.includes('int') || param.includes('seconds')) {
        // Integer/duration parameter
        params.push('30'); // Default 30 seconds
      } else if (param.includes('boolean')) {
        params.push('true');
      } else {
        params.push('/* TODO */');
      }
    }

    return params.join(', ');
  }

  /**
   * Generate test metadata
   */
  generateMetadata(params) {
    const { className, scenario, mappingResult, prerequisites, testType, platform, brand } = params;

    return {
      className,
      testType,
      platform,
      brand,
      scenario: {
        title: scenario.title,
        description: scenario.description
      },
      statistics: {
        totalSteps: mappingResult?.mappings?.length || 0,
        unmappedSteps: mappingResult?.unmapped?.length || 0,
        screens: prerequisites?.screenChain?.length || 0,
        imports: prerequisites?.prerequisites?.imports?.length || 0
      },
      generatedAt: new Date().toISOString()
    };
  }

  /**
   * Generate warnings for potential issues
   */
  generateWarnings(mappingResult, prerequisites) {
    const warnings = [];

    // Unmapped actions
    if (mappingResult?.unmapped?.length > 0) {
      warnings.push({
        type: 'unmapped_actions',
        message: `${mappingResult.unmapped.length} action(s) could not be mapped to existing methods`,
        actions: mappingResult.unmapped.map(a => a.action)
      });
    }

    // Low confidence mappings
    const lowConfidence = mappingResult?.mappings?.filter(m =>
      m.confidence && m.confidence < 0.7
    ) || [];

    if (lowConfidence.length > 0) {
      warnings.push({
        type: 'low_confidence',
        message: `${lowConfidence.length} mapping(s) have low confidence`,
        actions: lowConfidence.map(a => ({
          action: a.action,
          confidence: a.confidence
        }))
      });
    }

    // No navigation path
    if (!prerequisites?.prerequisites?.navigationToTarget ||
        prerequisites.prerequisites.navigationToTarget.length === 0) {
      warnings.push({
        type: 'no_navigation',
        message: 'No navigation path to target screen was generated'
      });
    }

    return warnings;
  }

  /**
   * Get agent statistics
   */
  getStats() {
    return {
      agent: 'TestComposerAgent',
      version: '1.0.0',
      defaultPackage: this.defaultPackage,
      codeStyle: this.codeStyle
    };
  }
}

// Export singleton instance
export const testComposerAgent = new TestComposerAgent();
export default testComposerAgent;
